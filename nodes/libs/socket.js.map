{
  "version": 3,
  "sources": ["src/libs/socket.js"],
  "sourcesContent": ["/** Manage Socket.IO on behalf of uibuilder\n * Singleton. only 1 instance of this class will ever exist. So it can be used in other modules within Node-RED.\n *\n * Copyright (c) 2017-2023 Julian Knight (Totally Information)\n * https://it.knightnet.org.uk, https://github.com/TotallyInformation/node-red-contrib-uibuilder\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* eslint-disable class-methods-use-this, sonarjs/no-duplicate-string, max-params */\n'use strict'\n\n/** --- Type Defs ---\n * @typedef {import('../../typedefs.js').runtimeRED} runtimeRED\n * @typedef {import('../../typedefs.js').MsgAuth} MsgAuth\n * @typedef {import('../../typedefs.js').uibNode} uibNode\n * @typedef {import('../../typedefs.js').uibConfig} uibConfig\n * @typedef {import('Express')} Express\n */\n\nconst path     = require('path')\nconst fs = require('fs-extra')\nconst socketio = require('socket.io')\nconst tilib    = require('./tilib')    // General purpose library (by Totally Information)\nconst uiblib   = require('./uiblib')   // Utility library for uibuilder\n// const security = require('./sec-lib') // uibuilder security module\nconst tiEventManager = require('@totallyinformation/ti-common-event-handler')\n\n/** Get client real ip address - NB: Optional chaining (?.) is node.js v14 not v12\n * @param {socketio.Socket} socket Socket.IO socket object\n * @returns {string | string[] | undefined} Best estimate of the client's real IP address\n */\nfunction getClientRealIpAddress(socket) {\n    let clientRealIpAddress\n    if ( 'headers' in socket.request && 'x-real-ip' in socket.request.headers) {\n        // get ip from behind a nginx proxy or proxy using nginx's 'x-real-ip header\n        clientRealIpAddress = socket.request.headers['x-real-ip']\n    } else if ( 'headers' in socket.request && 'x-forwarded-for' in socket.request.headers) {\n        // else get ip from behind a general proxy\n        if (socket.request.headers['x-forwarded-for'] === undefined) throw new Error('socket.request.headers[\"x-forwarded-for\"] is undefined')\n        if (!Array.isArray(socket.request.headers['x-forwarded-for'])) socket.request.headers['x-forwarded-for'] = [socket.request.headers['x-forwarded-for']]\n        clientRealIpAddress = socket.request.headers['x-forwarded-for'][0].split(',').shift()\n    } else if ( 'connection' in socket.request && 'remoteAddress' in socket.request.connection ) {\n        // else get ip from socket.request that returns the reference to the request that originated the underlying engine.io Client\n        clientRealIpAddress = socket.request.connection.remoteAddress\n    } else {\n        // else get ip from socket.handshake that is a object that contains handshake details\n        clientRealIpAddress = socket.handshake.address\n    }\n\n    // socket.client.conn.remoteAddress\n\n    // Switch to this code when node.js v14 becomes the baseline version\n    // const clientRealIpAddress =\n    //     //get ip from behind a nginx proxy or proxy using nginx's 'x-real-ip header\n    //     socket.request?.headers['x-real-ip']\n    //     //get ip from behind a general proxy\n    //     || socket.request?.headers['x-forwarded-for']?.split(',').shift() //if more thatn one x-fowared-for the left-most is the original client. Others after are successive proxys that passed the request adding to the IP addres list all the way back to the first proxy.\n    //     //get ip from socket.request that returns the reference to the request that originated the underlying engine.io Client\n    //     || socket.request?.connection?.remoteAddress\n    //     // get ip from socket.handshake that is a object that contains handshake details\n    //     || socket.handshake?.address\n\n    return clientRealIpAddress\n} // --- End of getClientRealIpAddress --- //\n\n/** Get client real ip address - NB: Optional chaining (?.) is node.js v14 not v12\n * @param {socketio.Socket} socket Socket.IO socket object\n * @param {uibNode} node Reference to the uibuilder node instance\n * @returns {string | string[] | undefined} Best estimate of the client's real IP address\n */\nfunction getClientPageName(socket, node) {\n    let pageName = socket.handshake.auth.pathName.replace(`/${node.url}/`, '')\n    if ( pageName.endsWith('/') ) pageName += 'index.html'\n    if ( pageName === '' ) pageName = 'index.html'\n\n    return pageName\n} // --- End of getClientPageName --- //\n\nclass UibSockets {\n    // TODO: Replace _XXX with #XXX once node.js v14 is the minimum supported version\n    /** Flag to indicate whether setup() has been run\n     * @type {boolean}\n     * @protected\n     */\n    // _isConfigured = false\n\n    /** Called when class is instantiated */\n    constructor() {\n        // setup() has not yet been run\n        this._isConfigured = false\n\n        //#region ---- References to core Node-RED & uibuilder objects ---- //\n        /** @type {runtimeRED|undefined} */\n        this.RED = undefined\n        /** @type {uibConfig|undefined} Reference link to uibuilder.js global configuration object */\n        this.uib = undefined\n        /** Reference to uibuilder's global log functions */\n        this.log = undefined\n        /** Reference to ExpressJS server instance being used by uibuilder\n         * Used to enable the Socket.IO client code to be served to the front-end\n         */\n        this.server = undefined\n        //#endregion ---- References to core Node-RED & uibuilder objects ---- //\n\n        //#region ---- Common variables ---- //\n\n        /** URI path for accessing the socket.io client from FE code. Based on the uib node instance URL.\n         * @constant {string} uib_socketPath */\n        this.uib_socketPath = undefined\n\n        /** An instance of Socket.IO Server */\n        this.io = undefined\n\n        /** Collection of Socket.IO namespaces\n         * Each namespace correstponds to a uibuilder node instance and must have a unique namespace name that matches the unique URL parameter for the node.\n         * The namespace is stored in the this.ioNamespaces object against a property name matching the URL so that it can be referenced later.\n         * Because this is a Singleton object, any reference to this module can access all of the namespaces (by url).\n         * The namespace has some uib extensions that track the originating node id (searchable in Node-RED), the number of connected clients\n         *   and the number of messages recieved.\n         * @type {!Object<string, socketio.Namespace>}\n         */\n        this.ioNamespaces = {}\n\n        //#endregion ---- ---- //\n\n    } // --- End of constructor() --- //\n\n    /** Assign uibuilder and Node-RED core vars to Class static vars.\n     *  This makes them available wherever this MODULE is require'd.\n     *  Because JS passess objects by REFERENCE, updates to the original\n     *    variables means that these are updated as well.\n     * @param {uibConfig} uib reference to uibuilder 'global' configuration object\n     * @param {Express} server reference to ExpressJS server being used by uibuilder\n     */\n    setup( uib, server ) {\n        if ( !uib || !server ) throw new Error('[uibuilder:socket.js:setup] Called without required parameters or uib and/or server are undefined.')\n        if (uib.RED === null) throw new Error('[uibuilder:socket.js:setup] uib.RED is null')\n\n        // Prevent setup from being called more than once\n        if ( this._isConfigured === true ) {\n            uib.RED.log.warn('[uibuilder:web:setup] Setup has already been called, it cannot be called again.')\n            return\n        }\n\n        /** reference to Core Node-RED runtime object */\n        this.RED = uib.RED\n\n        this.uib = uib\n        this.log = uib.RED.log\n        this.server = server\n\n        // TODO: Replace _XXX with #XXX once node.js v14 is the minimum supported version\n        this._socketIoSetup()\n\n        if (uib.configFolder === null) throw new Error('[uibuilder:socket.js:setup] uib.configFolder is null')\n\n        // If available, set up optional outbound msg middleware\n        this.outboundMsgMiddleware = function outboundMsgMiddleware( msg, url, channel ) { return null }\n        // Try to load the sioMsgOut middleware function - sioMsgOut applies to all outgoing msgs\n        const mwfile = path.join(uib.configFolder, uib.sioMsgOutMwName)\n        if ( fs.existsSync(mwfile) ) { // not interested if the file doesn't exist\n            try {\n                const sioMsgOut = require( mwfile )\n                if ( typeof sioMsgOut === 'function' ) { // if exported, has to be a function\n                    this.outboundMsgMiddleware = sioMsgOut\n                    this.log.trace('[uibuilder:socket:setup] sioMsgOut Middleware loaded successfully.')\n                } else {\n                    this.log.warn('[uibuilder:socket:setup] sioMsgOut Middleware failed to load - check that uibRoot/.config/sioMsgOut.js has a valid exported fn.')\n                }\n            } catch (e) {\n                this.log.warn(`[uibuilder:socket:setup] sioMsgOut middleware Failed to load. Reason: ${e.message}`)\n            }\n        }\n\n        this._isConfigured = true\n\n    } // --- End of setup() --- //\n\n    /**  Holder for Socket.IO - we want this to survive redeployments of each node instance\n     *   so that existing clients can be reconnected.\n     * Start Socket.IO - make sure the right version of SIO is used so keeping this separate from other\n     * modules that might also use it (path). This is only needed ONCE for ALL uib.instances of this node.\n     * Must only be run once and so is made an ECMA2018 private class method\n     * @private\n     */\n    _socketIoSetup() {\n        // Reference static vars\n        const uib = this.uib\n        const RED = this.RED\n        const log = this.log\n        const server = this.server\n\n        if (uib === undefined) throw new Error('uib is undefined')\n        if (RED === undefined) throw new Error('RED is undefined')\n        if (log === undefined) throw new Error('log is undefined')\n\n        const uibSocketPath = this.uib_socketPath = tilib.urlJoin(uib.nodeRoot, uib.moduleName, 'vendor', 'socket.io')\n\n        log.trace(`[uibuilder:socket:socketIoSetup] Socket.IO initialisation - Socket Path=${uibSocketPath}, CORS Origin=*` )\n        // Socket.Io server options, see https://socket.io/docs/v4/server-options/\n        let ioOptions = {\n            'path': uibSocketPath,\n            serveClient: true, // Needed for backwards compatibility\n            connectionStateRecovery: {\n                // the backup duration of the sessions and the packets\n                maxDisconnectionDuration: 120000, // Default = 2 * 60 * 1000 = 120000,\n                // whether to skip middlewares upon successful recovery\n                skipMiddlewares: true, // Default = true\n            },\n            // https://github.com/expressjs/cors#configuration-options, https://socket.io/docs/v3/handling-cors/\n            cors: {\n                origin: '*',\n                // allowedHeaders: ['x-clientid'],\n            },\n            /* // Socket.Io 3+ CORS is disabled by default, also options have changed.\n            // for CORS need to handle preflight request explicitly 'cause there's an\n            // Allow-Headers:X-ClientId in there.  see https://socket.io/docs/v4/handling-cors/\n            handlePreflightRequest: (req, res) => {\n                res.writeHead(204, {\n                    'Access-Control-Allow-Origin': req.headers['origin'], // eslint-disable-line dot-notation\n                    'Access-Control-Allow-Methods': 'GET,POST',\n                    'Access-Control-Allow-Headers': 'X-ClientId',\n                    'Access-Control-Allow-Credentials': true,\n                })\n                res.end()\n            }, */\n        }\n\n        // Merge in overrides from settings.js if given. NB: settings.uibuilder.socketOptions will override the above defaults.\n        if ( RED.settings.uibuilder && RED.settings.uibuilder.socketOptions ) {\n            ioOptions = Object.assign( {}, ioOptions, RED.settings.uibuilder.socketOptions )\n        }\n\n        // @ts-ignore ts(2769)\n        this.io = new socketio.Server(server, ioOptions) // listen === attach\n\n    } // --- End of socketIoSetup() --- //\n\n    /** Allow the isConfigured flag to be read (not written) externally\n     * @returns {boolean} True if this class as been configured\n     */\n    get isConfigured() {\n        return this._isConfigured\n    }\n\n    // ? Consider adding isConfigered checks on each method?\n\n    /** Output a msg to the front-end.\n     * @param {object} msg The message to output, include msg._socketId to send to a single client\n     * @param {string} url THe uibuilder id\n     * @param {string=} channel Optional. Which channel to send to (see uib.ioChannels) - defaults to client\n     */\n    sendToFe( msg, url, channel ) {\n        const uib = this.uib\n        const log = this.log\n\n        if (uib === undefined) throw new Error('uib is undefined')\n        if (log === undefined) throw new Error('log is undefined')\n\n        if ( channel === undefined ) channel = uib.ioChannels.client\n\n        const ioNs = this.ioNamespaces[url]\n\n        const socketId = msg._socketId || undefined\n\n        // Control msgs should say where they came from\n        if ( channel === uib.ioChannels.control && !msg.from ) msg.from = 'server'\n\n        // Process outbound middleware (middleware is loaded in this.setup)\n        try {\n            this.outboundMsgMiddleware( msg, url, channel, ioNs )\n        } catch (e) {\n            log.warn(`[uibuilder:socket:sendToFe] outboundMsgMiddleware middleware failed to run. Reason: ${e.message}`)\n        }\n\n        // TODO: Sending should have some safety validation on it. Is msg an object? Is channel valid?\n\n        // pass the complete msg object to the uibuilder client\n        if (socketId !== undefined) { // Send to specific client\n            log.trace(`[uibuilder:socket.js:sendToFe:${url}] msg sent on to client ${socketId}. Channel: ${channel}. ${JSON.stringify(msg)}`)\n            ioNs.to(socketId).emit(channel, msg)\n        } else { // Broadcast\n            log.trace(`[uibuilder:socket.js:sendToFe:${url}] msg sent on to ALL clients. Channel: ${channel}. ${JSON.stringify(msg)}`)\n            ioNs.emit(channel, msg)\n        }\n\n    } // ---- End of sendToFe ---- //\n\n    /** Output a normal msg to the front-end. Can override socketid\n     * Currently only used for the auto-reload on edit in admin-api-v2.js\n     * @param {object} msg The message to output\n     * @param {object} url The uibuilder instance url - will be unique. Used to lookup the correct Socket.IO namespace for sending.\n     * @param {string=} socketId Optional. If included, only send to specific client id (mostly expecting this to be on msg._socketID so not often required)\n     */\n    sendToFe2(msg, url, socketId) { // eslint-disable-line class-methods-use-this\n        const uib = this.uib\n        const ioNs = this.ioNamespaces[url]\n\n        if (uib === undefined) throw new Error('uib is undefined')\n        if (this.log === undefined) throw new Error('this.log is undefined')\n\n        if (socketId) msg._socketId = socketId\n\n        // TODO: This should have some safety validation on it\n        if (msg._socketId) {\n            this.log.trace(`[uibuilder:socket:sendToFe2:${url}] msg sent on to client ${msg._socketId}. Channel: ${uib.ioChannels.server}. ${JSON.stringify(msg)}`)\n            ioNs.to(msg._socketId).emit(uib.ioChannels.server, msg)\n        } else {\n            this.log.trace(`[uibuilder:socket:sendToFe2:${url}] msg sent on to ALL clients. Channel: ${uib.ioChannels.server}. ${JSON.stringify(msg)}`)\n            ioNs.emit(uib.ioChannels.server, msg)\n        }\n    } // ---- End of sendToFe2 ---- //\n\n    /** Send a uibuilder control message out of port #2\n     * Note: this.getClientDetails is used before calling this if client details needed\n     * @param {object} msg The message to output\n     * @param {uibNode} node Reference to the uibuilder node instance\n     */\n    sendCtrlMsg(msg, node) {\n        node.send( [null, msg])\n    }\n\n    /** Get client details for including in Node-RED messages\n     * @param {socketio.Socket} socket Reference to client socket connection\n     * @param {uibNode} node Reference to the uibuilder node instance\n     * @returns {object} Extracted key information\n     */\n    getClientDetails(socket, node) {\n\n        // Add page name meta to allow caches and other flows to send back to specific page\n        // Note, could use socket.handshake.auth.pageName instead\n        let pageName\n        if ( socket.handshake.auth.pathName ) {\n            pageName = getClientPageName(socket, node)\n        }\n\n        return {\n            '_socketId': socket.id,\n            // Let the flow know what v of uib client is in use\n            'version': socket.handshake.auth.clientVersion,\n            /** Do our best to get the actual IP addr of client despite any Proxies */\n            'ip': getClientRealIpAddress(socket),\n            /** What is the stable client id (set by uibuilder, retained till browser restart) */\n            'clientId': socket.handshake.auth.clientId,\n            /** What is the client tab identifier (set by uibuilder modern client) */\n            'tabId': socket.handshake.auth.tabId,\n            /** What was the originating uibuilder URL */\n            'url': node.url,\n            /** What was the originating page name (for SPA's) */\n            'pageName': pageName,\n            /** The browser's URL parameters */\n            'urlParams': socket.handshake.auth.urlParams,\n            /** How many times has this client reconnected (e.g. after sleep) */\n            'connections': socket.handshake.auth.connectedNum,\n            /** What type of client nav happened previously */\n            'lastNavType': socket.handshake.auth.lastNavType,\n            /** True if https/wss */\n            'tls': socket.handshake.secure,\n            /** When the client connected to the server */\n            'connectedTimestamp': (new Date(socket.handshake.issued)).toISOString(),\n            /** THe referring webpage, should be the full URL of the uibuilder page */\n            'referer': socket.request.headers.referer,\n            /** Is this client reconnected after temp loss? */\n            'recovered': socket.recovered,\n\n            // ? client time offset ?\n        }\n    }\n\n    /** Get a uib node instance namespace\n     * @param {string} url The uibuilder node instance's url (identifier)\n     * @returns {socketio.Namespace} Return a reference to the namespace of the specified uib instance for convenience in core code\n     */\n    getNs(url) {\n        return this.ioNamespaces[url]\n    }\n\n    /** Send a node-red msg either directly out of the node instance OR via return event name\n     * @param {object} msg Message object received from a client\n     * @param {uibNode} node Reference to the uibuilder node instance\n     */\n    sendIt(msg, node) {\n        if ( msg._uib && msg._uib.originator && (typeof msg._uib.originator === 'string') ) {\n            // const eventName = `node-red-contrib-uibuilder/return/${msg._uib.originator}`\n            tiEventManager.emit(`node-red-contrib-uibuilder/return/${msg._uib.originator}`, msg)\n        } else {\n            node.send(msg)\n        }\n    }\n\n    /** Socket listener fn for msgs from clients - NOTE that the optional sioUse middleware is also applied before this\n     * @param {object} msg Message object received from a client\n     * @param {socketio.Socket} socket Reference to the socket for this node\n     * @param {uibNode} node Reference to the uibuilder node instance\n     */\n    listenFromClient(msg, socket, node) {\n        const log = this.log\n        if (log === undefined) throw new Error('log is undefined')\n\n        node.rcvMsgCount++\n        log.trace(`[uibuilder:socket:${node.url}] Data received from client, ID: ${socket.id}, Msg: ${JSON.stringify(msg)}`)\n\n        // Make sure the incoming msg is a correctly formed Node-RED msg\n        switch ( typeof msg ) {\n            case 'string':\n            case 'number':\n            case 'boolean':\n                msg = { 'topic': node.topic, 'payload': msg }\n        }\n\n        // If the sender hasn't added msg._socketId, add the Socket.id now\n        if ( !Object.prototype.hasOwnProperty.call(msg, '_socketId') ) msg._socketId = socket.id\n\n        // If required, add/merge the client details to the msg using msg._uib\n        if (node.showMsgUib) {\n            if (!msg._uib) msg._uib = this.getClientDetails(socket, node)\n            else {\n                msg._uib = {\n                    ...msg._uib,\n                    ...this.getClientDetails(socket, node)\n                }\n            }\n        }\n\n        // Send out the message for downstream flows\n        // TODO: This should probably have safety validations!\n        this.sendIt(msg, node)\n\n    } // ---- End of listenFromClient ---- //\n\n    /** Add a new Socket.IO NAMESPACE\n     * Each namespace correstponds to a uibuilder node instance and must have a unique namespace name that matches the unique URL parameter for the node.\n     * The namespace is stored in the this.ioNamespaces object against a property name matching the URL so that it can be referenced later.\n     * Because this is a Singleton object, any reference to this module can access all of the namespaces (by url).\n     * The namespace has some uib extensions that track the originating node id (searchable in Node-RED), the number of connected clients\n     *   and the number of messages received.\n     * @param {uibNode} node Reference to the uibuilder node instance\n     */\n    addNS(node) {\n        const log = this.log\n        const uib = this.uib\n\n        if (log === undefined) throw new Error('log is undefined')\n        if (uib === undefined) throw new Error('uib is undefined')\n        if (this.io === undefined) throw new Error('this.io is undefined')\n\n        const ioNs = this.ioNamespaces[node.url] = this.io.of(node.url)\n\n        // @ts-expect-error Add some additional metadata to NS\n        const url = ioNs.url = node.url\n        // @ts-expect-error Allows us to track back to the actual node in Node-RED\n        ioNs.nodeId = node.id\n        // @ts-expect-error ioNs.useSecurity = node.useSecurity // Is security on for this node instance?\n        ioNs.rcvMsgCount = 0\n        // @ts-expect-error Make Node-RED's log available to middleware via custom ns property\n        ioNs.log = log\n        // ioNs.clientLog = {}\n\n        if (uib.configFolder === null) throw new Error('uib.configFolder is undefined')\n\n        /** Check for <uibRoot>/.config/sioMiddleware.js, use it if present.\n         * Applies ONCE on a new client connection.\n         * Had to move to addNS since MW no longer globally loadable since sio v3\n         */\n        const sioMwPath = path.join(uib.configFolder, 'sioMiddleware.js')\n        if ( fs.existsSync(sioMwPath) ) { // not interested if the file doesn't exist\n            try {\n                const sioMiddleware = require(sioMwPath)\n                if ( typeof sioMiddleware === 'function' ) {\n                    ioNs.use(sioMiddleware)\n                    log.trace(`[uibuilder:socket:addNs:${url}] Socket.IO sioMiddleware.js middleware loaded successfully for NS.`)\n                } else {\n                    log.warn(`[uibuilder:socket:addNs:${url}] Socket.IO middleware failed to load for NS - check that uibRoot/.config/sioMiddleware.js has a valid exported fn.`)\n                }\n            } catch (e) {\n                log.warn(`[uibuilder:socket:addNs:${url}] Socket.IO middleware failed to load for NS. Reason: ${e.message}`)\n            }\n        }\n\n        const that = this\n\n        ioNs.on('connection', (socket) => {\n\n            //#region ----- Event Handlers ----- //\n\n            // NOTE: as of sio v4, disconnect seems to be fired AFTER a connect when a client reconnects\n            socket.on('disconnect', (reason, description) => {\n\n                // ioNs.clientLog[socket.handshake.auth.clientId].connected = false\n\n                node.ioClientsCount = ioNs.sockets.size\n                log.trace(\n                    `[uibuilder:socket:${url}:disconnect] Client disconnected, clientCount: ${ioNs.sockets.size}, Reason: ${reason}, ID: ${socket.id}, IP Addr: ${getClientRealIpAddress(socket)}, Client ID: ${socket.handshake.auth.clientId}. For node ${node.id}`\n                )\n                node.statusDisplay.text = 'connected ' + ioNs.sockets.size\n                uiblib.setNodeStatus( node )\n\n                // Let the control output port know a client has disconnected\n                const ctrlMsg = {\n                    ...{\n                        'uibuilderCtrl': 'client disconnect',\n                        'reason': reason,\n                        'topic': node.topic || undefined,\n                        'from': 'server',\n                        'description': description,\n                    },\n                    ...that.getClientDetails(socket, node),\n                }\n\n                that.sendToFe(ctrlMsg, node.url, uib.ioChannels.control)\n\n                // Copy to port#2 for reference\n                that.sendCtrlMsg(ctrlMsg, node)\n\n                // Let other nodes know a client is disconnecting (via custom event manager)\n                tiEventManager.emit(`node-red-contrib-uibuilder/${this.url}/clientDisconnect`, ctrlMsg)\n\n            }) // --- End of on-connection::on-disconnect() --- //\n\n            // Listen for msgs from clients on standard channel\n            socket.on(uib.ioChannels.client, function(msg) {\n                that.listenFromClient(msg, socket, node )\n            }) // --- End of on-connection::on-incoming-client-msg() --- //\n\n            // Listen for msgs from clients on control channel\n            socket.on(uib.ioChannels.control, function(msg) {\n                node.rcvMsgCount++\n                log.trace(`[uibuilder:socket:${url}] Control Msg from client, ID: ${socket.id}, Msg: ${JSON.stringify(msg)}`)\n\n                // Make sure the incoming msg is a correctly formed Node-RED msg\n                switch ( typeof msg ) {\n                    case 'string':\n                    case 'number':\n                    case 'boolean':\n                        msg = { 'uibuilderCtrl': msg }\n                }\n\n                // Apply standard client details to the control msg\n                msg = { ...msg, ...that.getClientDetails(socket, node) }\n\n                // Control msgs should say where they came from\n                msg.from = 'client'\n\n                if ( !msg.topic ) msg.topic = node.topic\n\n                that.sendCtrlMsg(msg, node)\n\n            }) // --- End of on-connection::on-incoming-control-msg() --- //\n\n            // Listen for socket.io errors - output a control msg\n            socket.on('error', function(err) {\n\n                log.error(`[uibuilder:socket:addNs:${url}] ERROR received, ID: ${socket.id}, Reason: ${err.message}`)\n\n                // Let the control output port (port #2) know there has been an error\n                const ctrlMsg = {\n                    ...{\n                        uibuilderCtrl: 'socket error',\n                        error: err.message,\n                        from: 'server',\n                    },\n                    ...that.getClientDetails(socket, node),\n                }\n\n                that.sendCtrlMsg(ctrlMsg, node)\n\n            }) // --- End of on-connection::on-error() --- //\n\n            //#endregion ----- Event Handlers ----- //\n\n            //#region ---- run when client connects ---- //\n\n            // How many client connections are there?\n            node.ioClientsCount = ioNs.sockets.size\n\n            log.trace(\n                `[uibuilder:socket:addNS:${url}:connect] Client connected. ClientCount: ${ioNs.sockets.size}, Socket ID: ${socket.id}, IP Addr: ${getClientRealIpAddress(socket)}, Client ID: ${socket.handshake.auth.clientId}, Recovered?: ${socket.recovered}, Client Version: ${socket.handshake.auth.clientVersion}. For node ${node.id}`\n            )\n\n            if (uib.configFolder === null) throw new Error('uib.configFolder is undefined')\n\n            // Try to load the sioUse middleware function - sioUse applies to all incoming msgs\n            const mwfile = path.join(uib.configFolder, uib.sioUseMwName)\n            if ( fs.existsSync(mwfile) ) { // not interested if the file doesn't exist\n                try {\n                    const sioUseMw = require( mwfile )\n                    if ( typeof sioUseMw === 'function' ) { // if exported, has to be a function\n                        socket.use(sioUseMw)\n                        log.trace(`[uibuilder:socket:onConnect:${url}] sioUse sioUse.js middleware loaded successfully for NS ${url}.`)\n                    } else {\n                        log.warn(`[uibuilder:socket:onConnect:${url}] sioUse middleware failed to load for NS ${url} - check that uibRoot/.config/sioUse.js has a valid exported fn.`)\n                    }\n                } catch (e) {\n                    log.warn(`[uibuilder:socket:addNS:${url}] sioUse failed to load Use middleware. Reason: ${e.message}`)\n                }\n            }\n\n            node.statusDisplay.text = `connected ${ioNs.sockets.size}`\n            uiblib.setNodeStatus( node )\n\n            // Initial connect message to client\n            const msgClient = {\n                'uibuilderCtrl': 'client connect',\n                'serverTimestamp': (new Date()),\n                'topic': node.topic || undefined,\n                'version': uib.version,  // Let the front-end know what v of uib is in use\n                '_socketId': socket.id,\n            }\n            // msgClient.ip = getClientRealIpAddress(socket)\n            // msgClient.clientId = socket.handshake.auth.clientId\n            // msgClient.connections = socket.handshake.auth.connectedNum\n            // msgClient.pageName = socket.handshake.auth.pageName\n\n            // ioNs.clientLog[msg.clientId] = {\n            //     ip: msg.ip,\n            //     connections: msg.connections,\n            //     connected: true,\n            // }\n\n            // Let the clients know we are connecting\n            that.sendToFe(msgClient, node.url, uib.ioChannels.control)\n\n            // Send client connect control msg (via port #2)\n            const ctrlMsg = {\n                ...{\n                    uibuilderCtrl: 'client connect',\n                    topic: node.topic || undefined,\n                    from: 'server',\n                },\n                ...that.getClientDetails(socket, node),\n            }\n\n            that.sendCtrlMsg(ctrlMsg, node)\n\n            // Let other nodes know a client is connecting (via custom event manager)\n            tiEventManager.emit(`node-red-contrib-uibuilder/${this.url}/clientConnect`, ctrlMsg)\n\n            //#endregion ---- run when client connects ---- //\n\n        }) // --- End of on-connection() --- //\n\n    } // --- End of addNS() --- //\n\n    /** Remove the current clients and namespace for this node.\n     *  Called from uiblib.processClose.\n     * @param {uibNode} node Reference to the uibuilder node instance\n     */\n    removeNS(node) {\n\n        const ioNs = this.ioNamespaces[node.url]\n\n        // Disconnect all connected sockets for this Namespace (Socket.io v4+)\n        ioNs.disconnectSockets(true)\n\n        ioNs.removeAllListeners() // Remove all Listeners for the event emitter\n\n        // No longer works from socket.io v3+ //delete this.io.nsps[`/${node.url}`] // Remove from the server namespaces\n\n    } // --- End of removeNS() --- //\n\n} // ==== End of UibSockets Class Definition ==== //\n\n/** Singleton model. Only 1 instance of UibSockets should ever exist.\n * Use as: `const sockets = require('./libs/socket.js')`\n * Wrap in try/catch to force out better error logging if there is a problem\n * Downside of this approach is that you cannot directly pass in parameters. Use the startup(...) method instead.\n */\n\ntry { // Wrap in a try in case any errors creep into the class\n    const uibsockets = new UibSockets()\n    module.exports = uibsockets\n} catch (e) {\n    console.error(`[uibuilder:socket.js] Unable to create class instance. Error: ${e.message}`)\n}\n\n// EOF\n"],
  "mappings": "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",
  "names": ["path", "fs", "socketio", "tilib", "uiblib", "tiEventManager", "getClientRealIpAddress", "socket", "clientRealIpAddress", "getClientPageName", "node", "pageName", "UibSockets", "uib", "server", "msg", "url", "channel", "mwfile", "sioMsgOut", "e", "RED", "log", "uibSocketPath", "ioOptions", "ioNs", "socketId", "sioMwPath", "sioMiddleware", "that", "reason", "description", "ctrlMsg", "err", "sioUseMw", "msgClient", "uibsockets"]
}
