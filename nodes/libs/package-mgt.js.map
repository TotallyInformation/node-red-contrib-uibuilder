{
  "version": 3,
  "sources": ["src/libs/package-mgt.js"],
  "sourcesContent": ["/* eslint-disable class-methods-use-this */\n/** Manage npm packages\n *\n * Copyright (c) 2021-2023 Julian Knight (Totally Information)\n * https://it.knightnet.org.uk, https://github.com/TotallyInformation/node-red-contrib-uibuilder\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict'\n\n/** --- Type Defs ---\n * @typedef {import('../../typedefs.js').runtimeRED} runtimeRED\n * @typedef {import('../../typedefs.js').uibNode} uibNode\n * @typedef {import('../../typedefs.js').uibConfig} uibConfig\n * @typedef {import('../../typedefs.js').uibPackageJson} uibPackageJson\n */\n\nconst path = require('path')\n// const util = require('util')\nconst fs = require('fs-extra')\n// const tilib = require('./tilib')\nconst execa = require('execa')\n\nclass UibPackages {\n    /** PRIVATE Flag to indicate whether setup() has been run (ignore the false eslint error)\n     * @type {boolean}\n     */\n    #isConfigured = false\n\n    #logUndefinedError = new Error('pkgMgt: this.log is undefined')\n    #uibUndefinedError = new Error('pkgMgt: this.uib is undefined')\n    #rootFldrNullError = new Error('pkgMgt: this.uib.rootFolder is null')\n\n    /** @type {Array<string>} Updated by updateMergedPackageList which is called first in setup and then in various updates */\n    mergedPkgMasterList = []\n\n    /** @type {string} The name of the package.json file 'package.json' */\n    packageJson = 'package.json'\n\n    /** @type {uibPackageJson|null} The uibRoot package.json contents */\n    uibPackageJson\n\n    /** @type {string} Get npm's global install location */\n    globalPrefix // set in constructor\n\n    constructor() {\n\n        /** Get npm's global install location */\n        this.globalPrefix = this.npmGetGlobalPrefix()\n\n    } // ---- End of constructor ---- //\n\n    /** Gets the global install folder for npm & saves to a class variable\n     * @returns {string} The npm global install folder name\n     */\n    npmGetGlobalPrefix() { // eslint-disable-line class-methods-use-this\n        // Does not need setup to have run\n\n        const opts = {\n            'all': true,\n        }\n        const args = [\n            'config',\n            'get',\n            'prefix',\n        ]\n\n        let res\n        try {\n            const all = execa.sync('npm', args, opts)\n            res = all.stdout\n        } catch (e) {\n            console.error('>>>>>', e.all)\n            res = e.all  // Do we need to wrap this in a promise?\n        }\n        return res\n    } // ---- End of npmGetGlobalPrefix ---- //\n\n    /** Configure this class with uibuilder module specifics\n     * @param {uibConfig} uib uibuilder module-level configuration\n     */\n    setup( uib ) {\n        if ( !uib ) throw new Error('[uibuilder:UibPackages.js:setup] Called without required uib parameter or uib is undefined.')\n        if ( uib.RED === null ) throw new Error('[uibuilder:UibPackages.js:setup] uib.RED is null')\n\n        // Prevent setup from being called more than once\n        if ( this.#isConfigured === true ) {\n            uib.RED.log.warn('[uibuilder:UibPackages:setup] Setup has already been called, it cannot be called again.')\n            return\n        }\n\n        this.RED = uib.RED\n        this.uib = uib\n        const log = this.log = uib.RED.log\n\n        log.trace('[uibuilder:package-mgt:setup] Package Management setup started')\n\n        // Get the uibuilder root folder's package.json file and save to class var or create minimal version if one doesn't exist\n        const pj = this.uibPackageJson = this.getUibRootPJ()\n\n        // Update the version string to match uibuilder version\n        pj.version = this.uib.version\n        // Make sure there is a dependencies prop\n        if ( !pj.dependencies ) pj.dependencies = {}\n        // Make sure there is a uibuilder prop\n        if ( !pj.uibuilder ) pj.uibuilder = {}\n        // Make sure there is a uibuilder.packagedetails prop\n        if ( !pj.uibuilder.packages ) pj.uibuilder.packages = {}\n\n        this.pkgsQuickUpd()\n\n        // At this point we have the refs to uib and RED\n        this.#isConfigured = true\n\n        // Re-build package.json uibuilder.packages with details & rewrite file [after 3sec] (async)\n        this.updateInstalledPackageDetails()\n\n        log.trace('[uibuilder:package-mgt:setup] Package Management setup completed')\n    } // ---- End of setup ---- //\n\n    /** Do a fast update of the min data in pj.uibuilder.packages required for web.serveVendorPackages() - re-saves the package.json file */\n    pkgsQuickUpd() {\n        if ( this.uib === undefined ) throw this.#uibUndefinedError\n        if ( this.uib.rootFolder === null ) throw this.#rootFldrNullError\n\n        const pj = this.uibPackageJson\n\n        // Make sure no extra package details\n        for (const pkgName in pj.uibuilder.packages) {\n            if ( !pj.dependencies[pkgName] ) delete pj.uibuilder.packages[pkgName]\n        }\n        // Make sure all dependencies are reflected in uibuilder.packagedetails\n        for (const depName in pj.dependencies) {\n            if ( !pj.uibuilder.packages[depName] ) {\n                pj.uibuilder.packages[depName] = { installedVersion: pj.dependencies[depName] }\n            }\n        }\n        // Get folders for web:startup:serveVendorPackages()\n        for (const pkgName in pj.uibuilder.packages) {\n            const pkg = pj.uibuilder.packages[pkgName]\n            if ( this.uib.rootFolder === null ) throw this.#rootFldrNullError\n            // The actual location of the package folder\n            pkg.installFolder = path.join(this.uib.rootFolder, 'node_modules', pkgName)\n            // The base url used by uib - note this is changed if this is a scoped package\n            pkg.packageUrl = '/' + pkgName\n            // this.log.debug(`[uibuilder:package-mgt:pkgsQuickUpd] Updating '${pkgName}'. Fldr: '${pkg.installFolder}', URL: '${pkg.packageUrl}'.`)\n        }\n\n        // Re-save the updated file\n        // this.setUibRootPackageJson(pj)\n        this.writePackageJson(this.uib.rootFolder, pj)\n    }\n\n    /** Read the contents of a package.json file\n     * @param {string} folder The folder containing a package.json file\n     * @returns {object|null} Object representation of JSON if found otherwise null\n     */\n    readPackageJson(folder) {\n        if ( this.log === undefined ) throw this.#logUndefinedError\n\n        // Does not need setup to have finished running\n\n        let file = null\n        try {\n            //! TODO: Replace fs-extra\n            // const data = fs.readFileSync('./example.json')\n            // const obj = JSON.parse(data)\n            file = fs.readJsonSync( path.join(folder, this.packageJson), 'utf8' )\n            this.log.trace(`[uibuilder:package-mgt:readPackageJson] package.json file read successfully from ${folder}`)\n        } catch (err) {\n            this.log.error(`[uibuilder:package-mgt:readPackageJson] Failed to read package.json file from  ${folder}`, this.packageJson, err)\n        }\n        return file\n    } // ---- End of readPackageJson ---- //\n\n    /** Write updated <folder>/package.json (async)\n     * Also makes a backup copy to package.json.bak\n     * @param {string} folder The folder where to write the file\n     * @param {object} json The Object data to write to the file\n     */\n    async writePackageJson(folder, json) {\n        // Does not need setup to have finished running\n\n        const fileName = path.join( folder, this.packageJson )\n\n        try { // Make a backup copy\n            await fs.copy(fileName, `${fileName}.bak`)\n            this.log.trace(`[uibuilder:package-mgt:writePackageJson] package.json file successfully backed up in ${folder}`)\n        } catch (err) {\n            this.log.error(`[uibuilder:package-mgt:writePackageJson] Failed to copy package.json to backup.  ${folder}`, this.packageJson, err)\n        }\n\n        try {\n            await fs.writeJson(fileName, json, { spaces: 2 })\n            this.log.trace(`[uibuilder:package-mgt:writePackageJson] package.json file written successfully in ${folder}`)\n        } catch (err) {\n            this.log.error(`[uibuilder:package-mgt:writePackageJson] Failed to write package.json.  ${folder}`, this.packageJson, err)\n        }\n    }\n\n    /** Get the uibRoot package.json and return as object. Or, if not exists, return minimal object\n     * Note: Does not directly update this.uibPackageJson because of async timing\n     * @returns {object} uibRoot/package.json contents or a minimal version as an object\n     */\n    getUibRootPJ() {\n        if ( this.uib === undefined ) throw this.#uibUndefinedError\n        if ( this.log === undefined ) throw this.#logUndefinedError\n\n        // Does not need setup to have finished running\n\n        if ( this.uib.rootFolder === null ) throw this.#rootFldrNullError\n        const uibRoot = this.uib.rootFolder\n\n        const fileName = path.join( uibRoot, this.packageJson )\n\n        // Get it to class var or create minimal class var\n        let res = this.readPackageJson(uibRoot)\n\n        if (res === null) {\n            this.log.warn(`[uibuilder:package-mgt:getUibRootPJ] Could not read ${fileName}. Creating minimal version.`)\n            // Create a minimal pj\n            res = {\n                'name': 'uib_root',\n                'version': this.uib.version,\n                'description': 'Root configuration and data folder for uibuilder',\n                'scripts': {},\n                'dependencies': {},\n                'homepage': '',\n                'bugs': '',\n                'author': '',\n                'license': 'Apache-2.0',\n                'repository': '',\n                'uibuilder': {\n                    'packages': {},\n                },\n            }\n        }\n\n        return res\n    }\n\n    async updIndividualPkgDetails(pkgName, lsParsed) {\n        if ( this.uibPackageJson === null ) throw new Error('[uibuilder:UibPackages.js:updIndividualPkgDetails] this.uibPackageJson is null')\n        const pj = this.uibPackageJson\n\n        if ( pj.uibuilder === undefined || pj.uibuilder.packages === undefined || pj.dependencies === undefined ) throw new Error('pgkMgt:updIndividualPkgDetails: pj.uibuilder, pj.uibuilder.packages or pj.dependencies is undefined')\n\n        // Make sure only packages in uibRoot/package.json dependencies are processed\n        if ( !pj.dependencies[pkgName] ) return\n\n        const packages =  pj.uibuilder.packages\n\n        packages[pkgName] = {}\n        const pkg = packages[pkgName]\n\n        const lsp = lsParsed.dependencies[pkgName]\n        // save the version/location spec from the dependencies prop so everything is together\n        pkg.spec = pj.dependencies[pkgName]\n\n        if ( lsp.missing ) {\n            pkg.missing = true\n            pkg.problems = lsp.problems\n        } else {\n            // Get/Update package details\n            pkg.installFolder = lsp.path\n            pkg.installedVersion = lsp.version\n\n            /** If we can, lets work out what resource is actually needed\n             *  when using one of these packages in the browser.\n             *  If we can't, leave a ? to make it obvious\n             * Annoyingly, a few packages have decided to make the `browser` property an object instead of a string.\n             *   (e.g. vgauge) - ignore in that case as it isn't clear what the intent is.\n             */\n            if (lsp.browser && (typeof lsp.browser === 'string') ) pkg.estimatedEntryPoint = lsp.browser\n            else if (lsp.jsdelivr) pkg.estimatedEntryPoint = lsp.jsdelivr\n            else if (lsp.unpkg) pkg.estimatedEntryPoint = lsp.unpkg\n            else if (lsp.main) pkg.estimatedEntryPoint = lsp.main\n            else pkg.estimatedEntryPoint = '?'\n            if ( pkg.estimatedEntryPoint === 'none') pkg.estimatedEntryPoint = '?'\n\n            // Homepage - used for a help ref in the Editor\n            if (lsp.homepage) pkg.homepage = lsp.homepage\n            else pkg.homepage = `https://www.npmjs.com/search?q=${pkgName}`\n\n            // The base url used by uib - note this is changed if this is a scoped package\n            pkg.packageUrl = '/' + pkgName\n\n            // As the url may have changed (by removing scope), record the usable url\n            pkg.url = `../uibuilder/vendor${pkg.packageUrl}/${pkg.estimatedEntryPoint}`\n\n            // If the package name is npm @scoped, remove the scope, add leading / & track scope name\n            if ( pkgName.startsWith('@') ) {\n                // pkg.packageUrl = '/' + pkgName.replace(/^@.*\\//, '')\n                pkg.scope = pkgName.replace(pkg.packageUrl, '')\n            }\n        }\n\n        if ( pj.dependencies[pkgName] && pj.dependencies[pkgName].includes(':') ) {\n            // Must be installed from somewhere other than npmjs so don't try to find latest version\n            pkg.latestVersion = null\n            pkg.installedFrom = pj.dependencies[pkgName].split(':')[0]\n            pkg.outdated = {}\n        } else {\n            pkg.installedFrom = 'npm'\n\n            // Add current version details\n            let res = await this.npmOutdated(pkgName)\n            try {\n                res = JSON.parse(res)\n            } catch (e) { /* */ }\n            if ( res[pkgName] ) {\n                res = {\n                    current: res[pkgName].current,\n                    wanted: res[pkgName].wanted,\n                    latest: res[pkgName].latest,\n                }\n            }\n            pkg.outdated = res\n        }\n    }\n\n    /** Use npm to get detailed pkg info (slow, async) to pj.uibuilder.packages & rewrite the pj file */\n    async updateInstalledPackageDetails() {\n        const pj = this.uibPackageJson\n\n        if ( this.uib === undefined ) throw this.#uibUndefinedError\n        if ( this.uib.rootFolder === null ) throw this.#rootFldrNullError\n        const rootFolder = this.uib.rootFolder\n\n        let ls = ''\n        try {\n            ls = await this.npmListInstalled(rootFolder)\n        } catch {}\n\n        let lsParsed = { dependencies: {} }\n        try {\n            lsParsed = JSON.parse(ls)\n        } catch {}\n\n        // Make sure we have package details for all installed packages - NB: don't use await with forEach!\n        const depPkgNames = Object.keys(lsParsed.dependencies || {})\n        // await depPkgNames.forEach( async pkgName => {\n        //     await this.updIndividualPkgDetails(pkgName, lsParsed)\n        // })\n        // EITHER (serial)\n        // for ( const pkgName of depPkgNames ) {\n        //     await this.updIndividualPkgDetails(pkgName, lsParsed)\n        // }\n        // OR (parallel)\n        await Promise.all( depPkgNames.map(async (pkgName) => {\n            await this.updIndividualPkgDetails(pkgName, lsParsed)\n        }))\n\n        // (re)Write package.json\n        this.writePackageJson(rootFolder, pj)\n    }\n\n    /** Get <uibRoot>/package.json (create it if it doesn't exist), enhance with package details\n     * Also make version string same as uibuilder version\n     * @returns {object|null} Parsed version of <uibRoot>/package.json with uibuilder specific updates\n     */\n    getUibRootPackageJson() {\n        if ( this.log === undefined ) throw this.#logUndefinedError\n        if ( this.uib === undefined ) throw this.#uibUndefinedError\n        if ( this.uib.rootFolder === null ) throw this.#rootFldrNullError\n\n        const log = this.log\n\n        if ( this.#isConfigured !== true ) {\n            log.warn('[uibuilder:UibPackages:getUibRootPackageJson] Cannot run. Setup has not been called.')\n            return null\n        }\n\n        const uibRoot = this.uib.rootFolder\n        const fileName = path.join( uibRoot, this.packageJson )\n\n        // Make sure it exists & contains valid JSON - \n        if ( !fs.existsSync(fileName) ) {\n            log.warn('[uibuilder:package-mgt:getUibRootPackageJson] No uibRoot/package.json file, creating minimal file.')\n            this.setUibRootPackageJson()\n        }\n\n        // Get it\n        let pj = {}\n        try {\n            pj = this.readPackageJson(uibRoot)\n        } catch (e) {\n            log.error(`[uibuilder:package-mgt:getUibRootPackageJson] Error reading ${fileName}. ${e.message}`)\n            this.uibPackageJson = null\n            return null\n        }\n\n        // Make sure there is a dependencies prop\n        if ( !pj.dependencies ) pj.dependencies = {}\n        // Make sure there is a uibuilder prop\n        if ( !pj.uibuilder ) pj.uibuilder = {}\n        // Reset the packages list, we rebuild it below\n        pj.uibuilder.packages = {}\n\n        if (this.uibPackageJson.dependencies !== pj.dependencies ) {\n            log.info(`[uibuilder:package-mgt:getUibRootPackageJson] package.json dependencies changed`)\n            console.info({'pkg-deps': this.uibPackageJson.dependencies, 'memory-deps': pj.dependencies})\n        }\n\n        // Update the version string to match uibuilder version\n        pj.version = this.uib.version\n\n        // Make sure we have package details for all installed packages\n        Object.keys(pj.dependencies).forEach( packageName => {\n            // Get/Update package details\n            pj.uibuilder.packages[packageName] = this.getPackageDetails2(packageName, uibRoot)\n            // And save the version/location spec from the dependencies prop so everything is together\n            pj.uibuilder.packages[packageName].spec = pj.dependencies[packageName]\n\n            // Frig to pick up the version of Bootstrap installed with bootstrap-vue\n            if (packageName === 'bootstrap-vue' && !pj.dependencies.bootstrap ) {\n                pj.dependencies.bootstrap = pj.uibuilder.packages[packageName].bootstrap\n                pj.uibuilder.packages.bootstrap = this.getPackageDetails2('bootstrap', uibRoot)\n                pj.uibuilder.packages.bootstrap.spec = pj.dependencies.bootstrap\n            }\n        })\n\n        // Update the <uibRoot>/package.json file with updated details & Return it\n        if (this.setUibRootPackageJson(pj) === true) return pj\n        \n        // Failed\n        return null\n    } // ----- End of getUibRootPackageJson() ----- //\n\n    /** Write updated <uibRoot>/package.json\n     * @param {object} json The Object data to write to the file\n     * @returns {boolean} True if write was successful\n     */\n    setUibRootPackageJson(json) {\n        if ( this.log === undefined ) throw this.#logUndefinedError\n        if ( this.uib === undefined ) throw this.#uibUndefinedError\n        if ( this.uib.rootFolder === null ) throw this.#rootFldrNullError\n\n        if ( this.#isConfigured !== true ) {\n            this.log.warn('[uibuilder:UibPackages:setUibRootPackageJson] Cannot run. Setup has not been called.')\n            return\n        }\n\n        const uibRoot = this.uib.rootFolder\n        const fileName = path.join( uibRoot, this.packageJson )\n\n        if (!json) {\n            log.warn('[uibuilder:package-mgt:setUibRootPackageJson] Using dummy json')\n            json = {\n                'name': 'uib_root',\n                'version': this.uib.version,\n                'description': 'Root configuration and data folder for uibuilder',\n                'scripts': {},\n                'dependencies': {},\n                'homepage': '',\n                'bugs': '',\n                'author': '',\n                'license': 'Apache-2.0',\n                'repository': '',\n                'uibuilder': {\n                    'packages': {},\n                }\n            }\n        }\n\n        try {\n            fs.writeJsonSync(fileName, json, { spaces: 2 })\n            // Save it for use elsewhere\n            this.uibPackageJson = json\n            return true\n        } catch (e) {\n            log.error(`[uibuilder:package-mgt:setUibRootPackageJson] Error writing ${fileName}. ${e.message}`)\n            this.uibPackageJson = null\n            return false\n        }\n    }\n\n    /** Find install folder for a package - allows an array of locations to be given\n     * NOTE: require.resolve can be a little ODD!\n     *       When run from a linked package, it uses the link root not the linked location,\n     *       this throws out the tree search. That's why we have to try several different locations here.\n     *       Also, it finds the \"main\" script name which might not be in the package root.\n     *       Also, it won't find ANYTHING if a `main` entry doesn't exist :(\n     *       So we no longer use it, just search for folder names.\n     * @param {string} packageName - Name of the package who's install folder we are looking for.\n     * @param {string|Array<string>} installRoot Location to search. Can be an array of locations.\n     * @returns {null|string} Actual filing system path to the installed package\n     */\n    getPackagePath2(packageName, installRoot) {\n        if ( this.log === undefined ) throw this.#logUndefinedError\n\n        if ( this.#isConfigured !== true ) {\n            this.log.warn('[uibuilder:UibPackages:getPackagePath] Cannot run. Setup has not been called.')\n            return null\n        }\n\n        // If installRoot = string, make an array\n        if ( !Array.isArray(installRoot) ) installRoot = [installRoot]\n\n        for (const r of installRoot) {\n            const loc = path.join(r, 'node_modules', packageName)\n            if (fs.existsSync( loc )) return loc\n        }\n\n        this.log.warn(`[uibuilder:package-mgt:getPackagePath2] PACKAGE ${packageName} NOT FOUND`)\n        return null\n    } // ----  End of getPackagePath2 ---- //\n\n    /** Get the details for an installed package & update uibuilder specific details before returning it\n     * @param {string} packageName - Name of the package who's install folder we are looking for.\n     * @param {string} installRoot A uibuilder node instance - will search in node's root folder first\n     * @returns {object|null} Details object for an installed package\n     */\n    getPackageDetails2(packageName, installRoot) {\n        if ( this.log === undefined ) throw this.#logUndefinedError\n\n        if ( this.#isConfigured !== true ) {\n            this.log.warn('[uibuilder:UibPackages:getPackagePath2] Cannot run. Setup has not been called.')\n            return null\n        }\n\n        // Trim the input just in case\n        packageName = packageName.trim()\n\n        const folder = this.getPackagePath2(packageName, installRoot)\n        if ( folder === null ) throw new Error('folder is null')\n        const pkgJson = this.readPackageJson(folder)\n\n        const pkgDetails = { 'installFolder': folder }\n        // if ( pkgDetails === undefined ) throw new Error('pkgDetails is undefined')\n        if (pkgJson.version) pkgDetails.installedVersion = pkgJson.version\n\n        /** If we can, lets work out what resource is actually needed\n         *  when using one of these packages in the browser.\n         *  If we can't, leave a ? to make it obvious\n         * Annoyingly, a few packages have decided to make the `browser` property an object instead of a string.\n         *   (e.g. vgauge) - ignore in that case as it isn't clear what the intent is.\n         */\n        if (pkgJson.browser && (typeof pkgJson.browser === 'string') ) pkgDetails.estimatedEntryPoint = pkgJson.browser\n        else if (pkgJson.jsdelivr) pkgDetails.estimatedEntryPoint = pkgJson.jsdelivr\n        else if (pkgJson.unpkg) pkgDetails.estimatedEntryPoint = pkgJson.unpkg\n        else if (pkgJson.main) pkgDetails.estimatedEntryPoint = pkgJson.main\n        else pkgDetails.estimatedEntryPoint = '?'\n        if ( pkgDetails.estimatedEntryPoint === 'none') pkgDetails.estimatedEntryPoint = '?'\n\n        // Homepage - used for a help ref in the Editor\n        if (pkgJson.homepage) pkgDetails.homepage = pkgJson.homepage\n        else pkgDetails.homepage = `https://www.npmjs.com/search?q=${packageName}`\n\n        // The base url used by uib - note this is changed if this is a scoped package\n        pkgDetails.packageUrl = '/' + packageName\n\n        // Work out what kind of package this is\n\n        // If the package name is npm @scoped, remove the scope, add leading / & track scope name\n        if ( pkgDetails.packageUrl.startsWith('@') ) {\n            pkgDetails.packageUrl = '/' + packageName.replace(/^@.*\\//, '')\n            pkgDetails.scope = packageName.replace(pkgDetails.packageUrl, '')\n        }\n\n        // As the url may have changed (by removing scope), record the usable url\n        pkgDetails.url = `../uibuilder/vendor${pkgDetails.packageUrl}/${pkgDetails.estimatedEntryPoint}`\n\n        // Frig to pick up the version of Bootstrap installed with bootstrap-vue\n        if (packageName === 'bootstrap-vue') {\n            pkgDetails.bootstrap = pkgJson.dependencies.bootstrap\n        }\n\n        // Add current version details\n        // pkgDetails.outdated = this.npmOutdated(packageName)\n        // console.log('pkgDetails.outdated', pkgDetails.outdated)\n        // this.npmOutdated(packageName)\n        //     .then(res => {\n        //         try {\n        //             res = JSON.parse(res)\n        //         } catch(e) { /* */ }\n        //         if ( res[packageName] ) {\n        //             res = {\n        //                 current: res[packageName].current,\n        //                 wanted: res[packageName].wanted,\n        //                 latest: res[packageName].latest,\n        //             }\n        //         }\n        //         pkgDetails.outdated = res\n        //         return true\n        //     })\n        //     .catch( err => {\n        //         //\n        //     })\n\n        return pkgDetails\n    } // ----  End of getPackageDetails2 ---- //\n\n    //#region --- DEPRECATED ---\n\n    /** Update all of the installed packages\n     */\n    updateInstalledPackages() {\n        this.log.error('[uibuilder:UibPackages:updateInstalledPackages] FUNCTION IS DEPRECATED.')\n        console.trace()\n\n        console.trace('package-mgt.js:updateInstalledPackages')\n    } // ---- End of updateInstalledPackages ---- //\n\n    /** !DEPRECATED!  Find install folder for a package\n     */\n    getPackagePath() {\n        this.log.error('[uibuilder:UibPackages:getPackagePath] FUNCTION IS DEPRECATED.')\n        console.trace()\n\n        console.trace('package-mgt.js:getPackagePath')\n    } // ----  End of getPackagePath ---- //\n\n    /** Update the master name list of possible packages that could be served to the front-end\n     */\n    updateMergedPackageList() {\n        this.log.error('[uibuilder:UibPackages:updateMergedPackageList] FUNCTION IS DEPRECATED.')\n        console.trace()\n\n        console.trace('package-mgt.js:updateMergedPackageList')\n    } // ---- End of updateMergedPackageList ---- //\n\n    //#endregion --- DEPRECATED ---\n\n    /** Install an npm package\n     * NOTE: This fn does not update the list of packages\n     *       because that is built from the package.json file\n     *       and that is updated by calling web.serveVendorPackages()\n     *       which can't be done here - The calling admin API's do that\n     *       Editor->API->This fn->API cont.->web.serveVendorPackages->getUibRootPackageJson->API cont2->Editor\n     * @param {string} url Node instance url\n     * @param {string} pkgName The npm name of the package (with scope prefix, version, etc if needed)\n     * @param {string} [tag] Default=''. Specifier for a version, tag, branch, etc. with leading @ for npm and # for GitHub installs\n     * @param {string} [toLocation] Where to install to. Defaults to uibRoot\n     * @returns {Promise<string>} [Combined stdout/stderr, updated list of package details]\n     */\n    async npmInstallPackage(url, pkgName, tag = '', toLocation = '') {\n        if ( this.log === undefined ) throw this.#logUndefinedError\n\n        if ( this.#isConfigured !== true ) {\n            this.log.warn('[uibuilder:UibPackages:npmInstallPackage] Cannot run. Setup has not been called.')\n            return ''\n        }\n\n        if ( this.uib === undefined ) throw this.#uibUndefinedError\n        if ( this.uib.rootFolder === null ) throw new Error('this.log.rootFolder is null')\n        if ( toLocation === '' ) toLocation = this.uib.rootFolder\n\n        // https://github.com/sindresorhus/execa#options\n        const opts = {\n            'cwd': toLocation,\n            'all': true,\n        }\n        const args = [ // `npm install --no-audit --no-update-notifier --save --production --color=false --no-fund --json ${params.package}@latest`\n            'install',\n            '--no-fund',\n            '--no-audit',\n            '--no-update-notifier',\n            '--save',\n            '--production',\n            '--color=false',\n            // '--json',\n            pkgName + tag,\n        ]\n\n        // Don't need a try since we don't do any processing on an execa error - if cmd fails, the promise is rejected\n        const { all } = await execa('npm', args, opts)\n        this.log.info(`[uibuilder:UibPackages:npmInstallPackage] npm output: \\n ${all}\\n `)\n\n        return /** @type {string} */ (all)\n\n    } // ---- End of installPackage ---- //\n\n    /** Install an npm package\n     * NOTE: This fn does not update the list of packages - see install above for reasons.\n     * @param {string} pkgName The npm name of the package (with scope prefix, version, etc if needed)\n     * @returns {Promise<string>} Combined stdout/stderr\n     */\n    async npmRemovePackage(pkgName) {\n        if ( this.log === undefined ) throw this.#logUndefinedError\n        if ( this.uib === undefined ) throw this.#uibUndefinedError\n        if ( this.uib.rootFolder === null ) throw this.#rootFldrNullError\n\n        if ( this.#isConfigured !== true ) {\n            this.log.warn('[uibuilder:UibPackages:npmRemovePackage] Cannot run. Setup has not been called.')\n            return ''\n        }\n\n        // https://github.com/sindresorhus/execa#options\n        const opts = {\n            'cwd': this.uib.rootFolder,\n            'all': true,\n        }\n        const args = [\n            'uninstall',\n            '--save',\n            '--color=false',\n            '--no-fund',\n            '--no-audit',\n            '--no-update-notifier',\n            // '--json',\n            pkgName,\n        ]\n\n        // Don't need a try since we don't do any processing on an execa error - if cmd fails, the promise is rejected\n        const { all } = await execa('npm', args, opts)\n        this.log.info(`[uibuilder:UibPackages:npmRemovePackage] npm output: \\n ${all}\\n `)\n\n        return /** @type {string} */ (all)\n\n    } // ---- End of removePackage ---- //\n\n    /** List all npm packages installed at the top-level of a folder\n     * @param {string=} folder The folder to start the list in\n     * @returns {Promise<string>} Command output\n     */\n    async npmListInstalled(folder) {\n        this.log.trace('[uibuilder:package-mgt:npmListInstalled] npm list installed started')\n\n        // if ( this._isConfigured !== true ) {\n        //     this.log.warn('[uibuilder:UibPackages:npmListInstalled] Cannot run. Setup has not been called.')\n        //     return\n        // }\n\n        // https://github.com/sindresorhus/execa#options\n        const opts = {\n            'cwd': folder,\n            'all': true,\n        }\n        const args = [\n            'list',\n            '--long',\n            '--json',\n            '--depth=0',\n        ]\n\n        let res\n        try {\n            const { stdout } = await execa('npm', args, opts)\n            // console.log('>>>>>', stdout)\n            res = stdout\n        } catch (e) {\n            // console.log('>>>>>', e.message)\n            res = e.stdout\n        }\n\n        this.log.trace('[uibuilder:package-mgt:npmListInstalled] npm list installed completed')\n        return res\n    } // ---- End of npmListInstalled ---- //\n\n    /** Get the latest version string for a package\n     * @param {string} pkgName The npm name of the package (with scope prefix, version, etc if needed)\n     * @returns {Promise<any>} Combined stdout/stderr\n     */\n    async npmOutdated(pkgName) {\n        if ( this.log === undefined ) throw this.#logUndefinedError\n        if ( this.uib === undefined ) throw this.#uibUndefinedError\n        if ( this.uib.rootFolder === null ) throw this.#rootFldrNullError\n\n        if ( this.#isConfigured !== true ) {\n            this.log.warn('[uibuilder:UibPackages:npmOutdated] Cannot run. Setup has not been called.')\n            return\n        }\n\n        // https://github.com/sindresorhus/execa#options\n        const opts = {\n            'cwd': this.uib.rootFolder,\n            'all': true,\n        }\n        const args = [ // `npm remove --no-audit --no-update-notifier --color=false --json ${params.package}` //  --save-prefix=\"~\"\n            'outdated',\n            '--json',\n            pkgName,\n        ]\n\n        let res\n        try {\n            const { stdout } = await execa('npm', args, opts)\n            // const {stdout} = execa.sync('npm', args, opts)\n            res = stdout\n        } catch (err) {\n            res = err.stdout\n        }\n\n        this.log.trace(`[uibuilder:UibPackages:npmOutdated] npm output: \\n ${res}\\n `)\n\n        return res\n\n    } // ---- End of npmOutdated ---- //\n\n    /** Update an npm package (Not yet in use)\n     * @param {string} pkgName The npm name of the package (with scope prefix, version, etc if needed)\n     * @returns {Promise<string>} Combined stdout/stderr\n     */\n    async npmUpdate(pkgName) {\n        if ( this.log === undefined ) throw this.#logUndefinedError\n\n        if ( this.#isConfigured !== true ) {\n            this.log.warn('[uibuilder:UibPackages:npmUpdate] Cannot run. Setup has not been called.')\n            return ''\n        }\n\n        if ( this.uib === undefined ) throw this.#uibUndefinedError\n        if ( this.uib.rootFolder === null ) throw new Error('this.log.rootFolder is null')\n        // if ( toLocation === '' ) toLocation = this.uib.rootFolder\n        const toLocation = this.uib.rootFolder\n\n        // https://github.com/sindresorhus/execa#options\n        const opts = {\n            'cwd': toLocation,\n            'all': true,\n        }\n        const args = [\n            'update',\n            '--no-fund',\n            '--no-audit',\n            '--no-update-notifier',\n            '--save',\n            '--production',\n            '--color=false',\n            // '--json',\n            pkgName,\n        ]\n\n        // Don't need a try since we don't do any processing on an execa error - if cmd fails, the promise is rejected\n        const { all } = await execa('npm', args, opts)\n        this.log.info(`[uibuilder:UibPackages:npmUpdate] npm output: \\n ${all}\\n `)\n\n        return /** @type {string} */ (all)\n\n    }\n\n} // ----- End of UibPackages ----- //\n\n/** Singleton model. Only 1 instance of UibWeb should ever exist.\n * Use as: `const packageMgt = require('./package-mgt.js')`\n */\n// @ts-ignore\nconst uibPackages = new UibPackages()\nmodule.exports = uibPackages\n\n// EOF\n"],
  "mappings": "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",
  "names": ["path", "fs", "execa", "UibPackages", "#isConfigured", "#logUndefinedError", "#uibUndefinedError", "#rootFldrNullError", "opts", "args", "res", "e", "uib", "log", "pj", "pkgName", "depName", "pkg", "folder", "file", "err", "json", "fileName", "uibRoot", "lsParsed", "packages", "lsp", "rootFolder", "ls", "depPkgNames", "packageName", "installRoot", "r", "loc", "pkgJson", "pkgDetails", "url", "tag", "toLocation", "all", "stdout", "uibPackages"]
}
