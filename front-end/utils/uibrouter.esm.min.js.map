{
  "version": 3,
  "sources": ["src/front-end-module/uibrouter.js"],
  "sourcesContent": ["/* eslint-disable no-undef */\n// @ts-nocheck\n/** A simple, vanilla JavaScript front-end router class\n * Included in node-red-contrib-uibuilder but is not dependent on it.\n * May be used in other contexts as desired.\n *\n * Copyright (c) 2023-2024 Julian Knight (Totally Information)\n * https://it.knightnet.org.uk\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Type definitions\n * routeDefinition\n * @typedef {object} routeDefinition Single route configuration\n * @property {string} id REQUIRED. Route ID\n * @property {string} src REQUIRED for external, optional for internal (default=route id). CSS Selector for template tag routes, url for external routes\n * @property {\"url\"|undefined} [type] OPTIONAL, default=internal route. \"url\" for external routes\n * @property {string} [title] OPTIONAL, default=route id. Text to use as a short title for the route\n * @property {string} [description] OPTIONAL, default=route id. Text to use as a long description for the route\n * UibRouterConfig\n * @typedef {object} UibRouterConfig Configuration for the UiBRouter class instances\n * @property {routeDefinition[]} routes REQUIRED. Array of route definitions\n * @property {string} [defaultRoute] OPTIONAL, default=1st route. If set to a route id, that route will be automatically shown on load\n * @property {string} [routeContainer] OPTIONAL, default='#uibroutecontainer'. CSS Selector for an HTML Element containing routes\n * @property {boolean} [hide] OPTIONAL, default=false. If TRUE, routes will be hidden/shown on change instead of removed/added\n * @property {boolean} [templateLoadAll] OPTIONAL, default=false. If TRUE, all external route templates will be loaded when the router is instanciated. Default is to lazy-load external templates\n * @property {boolean} [templateUnload] OPTIONAL, default=true. If TRUE, route templates will be unloaded from DOM after access.\n */\n\nclass UibRouter { // eslint-disable-line no-unused-vars\n    //#region --- Variables ---\n    /** Class version */\n    static version = '1.2.0' // 2024-01-02 16:04\n\n    /** Configuration settings @type {UibRouterConfig} */\n    config\n    /** Reference to the container DOM element - set in setup() @type {HTMLDivElement} */\n    routeContainerEl\n    /** The current route id after doRoute() has been called */\n    currentRouteId\n    /** The previous route id after doRoute() has been called */\n    previousRouteId\n    /** Array of route ID's (created in constructor) */\n    routeIds = []\n\n    /** Internal only. Set to true when the _start() method has been called */\n    #startDone = false\n    //#endregion --- ----- ---\n\n    //#region --- Internal Methods ---\n    /** Class constructor\n     * @param {UibRouterConfig} routerConfig Configuration object\n     */\n    constructor(routerConfig) {\n        // Fetch is on desktop browsers since 2017 at latest. Not so much on mobile (Android!)\n        // May need a polyfill on mobile or old browsers.\n        if (!fetch) throw new Error('[uibrouter:constructor] UibRouter requires `fetch`. Please use a current browser or load a fetch polyfill.')\n\n        if (!routerConfig) throw new Error('[uibrouter:constructor] No config provided')\n        if (!routerConfig.routes) throw new Error('[uibrouter:constructor] No routes provided in routerConfig')\n\n        // Save the config\n        this.config = routerConfig\n\n        // Add a default route container uf needed\n        if (!this.config.routeContainer) this.config.routeContainer = '#uibroutecontainer'\n        // If no default set in config, set to the first entry\n        if (!this.config.defaultRoute && this.config.routes[0] && this.config.routes[0].id) this.config.defaultRoute = this.config.routes[0].id\n        // Other defaults\n        if (!this.config.hide) this.config.hide = false\n        if (!this.config.templateLoadAll) this.config.templateLoadAll = false\n        if (!this.config.templateUnload) this.config.templateUnload = true\n\n        // Create/access the route container element, sets this.routeContainerEl\n        this._setRouteContainer()\n\n        this._updateRouteIds()\n\n        if (this.config.templateLoadAll === false) {\n            this._start()\n        } else {\n            console.info('[uibrouter] Pre-loading all external templates')\n            // Load all external route templates async in parallel - NB: Object.values works on both arrays and objects\n            // Note that final `then` is called even if no external routes are given\n            Promise.allSettled(Object.values(routerConfig.routes).filter(r => r.type && r.type === 'url').map(this._loadExternal))\n                .then( results => {\n                    results.filter( res => res.status === 'rejected').forEach(res => {\n                        console.error(res.reason)\n                    })\n                    results.filter( res => res.status === 'fulfilled').forEach(res => {\n                        console.log('allSettled results', res, results)\n                        this._appendExternalTemplates(res.value)\n                    })\n                    // Everything is loaded that can be so we can start\n                    this._start()\n                    return true\n                })\n                .catch( reason => {\n                    console.error(reason)\n                })\n        }\n\n        if (uibuilder) uibuilder.set('uibrouterinstance', this)\n    }\n\n    /** Save a reference to, and create if necessary, the HTML element to hold routes */\n    _setRouteContainer() {\n        const body = document.getElementsByTagName('body')[0]\n        // Get reference to route container or create it\n        let routeContainerEl = this.routeContainerEl = document.querySelector(this.config.routeContainer)\n        if (!routeContainerEl) {\n            // throw new Error(`Route container element with CSS selector '${routerConfig.routeContainer}' not found in HTML`)\n            const tempContainer = document.createElement('div')\n            tempContainer.setAttribute('id', this.config.routeContainer.replace('#', ''))\n            body.append(tempContainer)\n            routeContainerEl = this.routeContainerEl = document.querySelector(this.config.routeContainer)\n        }\n    }\n\n    /** Apply fetched external elements to templates tags under the head tag\n     * @param {HTMLElement[]} loadedElements Array of loaded external elements to add as templates to the head tag\n     * @returns {number} Count of load errors\n     */\n    _appendExternalTemplates(loadedElements) {\n        if (!Array.isArray(loadedElements)) loadedElements = [loadedElements]\n        // console.log('_appendExternalTemplates', loadedElements)\n        const head = document.getElementsByTagName('head')[0]\n        let errors = 0\n        // Append the loaded content to the main container\n        loadedElements.forEach(element => {\n            if (Array.isArray(element)) {\n                console.error(...element)\n                errors++\n            } else {\n                head.append(element)\n            }\n        })\n        return errors\n    }\n\n    /** Called once all external templates have been loaded */\n    async _start() {\n        if (this.#startDone === true) return // Don't run this again\n\n        // Go to url hash route or default route if no route in url\n        await this.doRoute(this.keepHashFromUrl(window.location.hash))\n\n        // After initial route set, listen for url hash changes and process route change\n        window.addEventListener('hashchange', (event) => this._hashChange(event) )\n\n        // Events on fully loaded ...\n        document.dispatchEvent(new CustomEvent('uibrouter:loaded'))\n        if (uibuilder) uibuilder.set('uibrouter', 'loaded') // eslint-disable-line no-undef\n\n        this.#startDone = true // Don't run this again\n    }\n\n    /** Called when the URL Hash changes\n     * @param {HashChangeEvent} event URL Hash change event object\n     */\n    _hashChange(event) {\n        // console.log(`[uibrouter] hashchange: ${this.keepHashFromUrl(event.oldURL)} => ${this.keepHashFromUrl(event.newURL)}` )\n        this.doRoute(event)\n    }\n\n    /** Create DOM route content from a route template (internal or external)\n     * Route templates have to be a `<template>` tag with an ID that matches the route id.\n     * @param {string} routeId ID of the route definition to use to create the content\n     * @returns {boolean} True if the route content was created successfully, false otherwise\n     */\n    async _createRouteContent(routeId) {\n        // Try to reference the template for this route\n        let rContent = document.querySelector(`#${routeId}`)\n\n        if (!rContent) {\n            // If external template content doesn't exist, try to load it now (but only try once)\n            const r = this.getRouteConfigById(routeId)\n            if (r.type && r.type === 'url') {\n                let loadedEls\n                try {\n                    loadedEls = await this._loadExternal(r)\n                } catch (e) {\n                    throw new Error(e.message, e)\n                }\n\n                if (!loadedEls) throw new Error(`[uibrouter:createRouteContent] No route template found for route selector '#${routeId}'. Does the link url match a defined route id?`)\n\n                // Apply fetched external elements to templates tags under the head tag\n                this._appendExternalTemplates(loadedEls)\n\n                // And check that the template now actually exists\n                rContent = document.querySelector(`#${routeId}`)\n\n                if (!rContent) throw new Error(`[uibrouter:createRouteContent] No route template found for route selector '#${routeId}'. Does the link url match a defined route id?`)\n            } else {\n                // type not not external so we can't do anything when it doesn't actually exist\n                throw new Error(`[uibrouter:createRouteContent] No route template found for route selector '#${routeId}'. Does the link url match a defined route id?`)\n            }\n        }\n\n        // Clone the template\n        const docFrag = rContent.content.cloneNode(true)\n\n        // Have to re-apply the scripts to make them run - only for external templates\n        if (this.isRouteExternal(routeId)) this._applyScripts(docFrag)\n\n        // Create the route wrapper div with data-route attrib\n        const tempContainer = document.createElement('div')\n        tempContainer.dataset.route = routeId\n        tempContainer.append(docFrag)\n\n        // And finally try to append to the container\n        try {\n            this.routeContainerEl.append(tempContainer)\n        } catch (e) {\n            throw new Error(`[uibrouter:createRouteContent] Failed to apply route id '${routeId}'. \\n ${e.message}`)\n        }\n\n        // If we get here, everything is good\n        return true\n    }\n\n    /** Loads an external HTML file into a `<template>` tag, adding the router id as the template id. Or throws.\n     * @param {routeDefinition} routeDefinition Configuration for a single route\n     * @returns {HTMLTemplateElement[]} An HTMLTemplateElement that will provide the route content\n     */\n    async _loadExternal(routeDefinition) {\n        if (!routeDefinition) throw new Error('[uibrouter:loadExternal] Error loading route template. No route definition provided.')\n        // Obviously, this only works for internal routes\n        if (!routeDefinition.src) {\n            if (!routeDefinition.type || (routeDefinition.type && routeDefinition.type !== 'url'))routeDefinition.src = routeDefinition.id\n            else throw new Error('[uibrouter:loadExternal] Error loading route template. `src` property not defined')\n        }\n\n        const id = routeDefinition.id\n\n        let response\n        try {\n            response = await fetch(routeDefinition.src)\n        } catch (e) {\n            throw new Error(`[uibrouter:loadExternal] Error loading route template HTML for route: ${routeDefinition.id}, src: ${routeDefinition.src}. Error: ${e.message}`, e)\n        }\n\n        // Fetch failed?\n        if (response.ok === false) throw new Error(`[uibrouter:loadExternal] Fetch failed to return data for route: ${routeDefinition.id}, src: ${routeDefinition.src}. Status: ${response.statusText} (${response.status})`, [routeDefinition.id, routeDefinition.src, response.status, response.statusText])\n\n        /** @type {string & any[]} */\n        const htmlText = await response.text()\n\n        // Check to see if template already exists, if so, remove it\n        try {\n            const chkTemplate = document.querySelector(`#${id}`)\n            if (chkTemplate) chkTemplate.remove()\n        } catch (e) {}\n\n        // Return the template\n        const tempContainer = document.createElement('template')\n        tempContainer.innerHTML = htmlText\n        tempContainer.setAttribute('id', id)\n        return tempContainer\n    }\n\n    /** Remove/re-apply scripts in a container Element so that they are executed.\n     * @param {HTMLElement} tempContainer HTML Element of container to process\n     */\n    _applyScripts(tempContainer) {\n        const scripts = tempContainer.querySelectorAll('script')\n        scripts.forEach( scr => {\n            const newScript = document.createElement('script')\n            newScript.textContent = scr.innerText\n            tempContainer.append(newScript)\n            scr.remove() // remove the origin\n        })\n    }\n\n    /** Update this.routeIds array from this.config (on start and after add/remove routes) */\n    _updateRouteIds() {\n        this.routeIds = new Set(Object.values(routerConfig.routes).map( r => r.id ))\n    }\n    //#endregion --- ----- --\n\n    /** Process a routing request\n     * @param {PointerEvent|MouseEvent|HashChangeEvent|TouchEvent|string} routeSource Either string containing route id or DOM Event object either click/touch on element containing `href=\"#routeid\"` or Hash URL change event\n     */\n    async doRoute(routeSource) {\n        if (!routeSource) routeSource = this.config.defaultRoute\n\n        const container = this.routeContainerEl\n        if (!container) throw new Error('[uibrouter:doRoute] Cannot route, has router.setup() been called yet?')\n\n        // Remove all the url and query param text and any leading # - returns '' if no current hash\n        const currentHash = this.keepHashFromUrl(window.location.hash)\n\n        // If no route source provided, take the current hash (which might be '' and that will trigger the default route if defined)\n        if (!routeSource) routeSource = currentHash\n\n        let newRouteId, oldRouteId\n\n        // Define new and old routes depending on different call types\n        if (typeof routeSource === 'string') { // Manually provided route id\n            // console.log(`[uibrouter:doRoute] manual: ${currentHash} => ${this.keepHashFromUrl(routeSource)}. Current: ${currentHash}` )\n            newRouteId = this.keepHashFromUrl(routeSource)\n            oldRouteId = currentHash\n            // If no hash & config has default, set the default as new\n            if (newRouteId === '' && this.config.defaultRoute) newRouteId = this.config.defaultRoute\n            // If the new route id not the same as the current one in the url hash, just change the current hash & exit\n            if (newRouteId !== currentHash ) {\n                window.location.hash = `#${newRouteId}`\n                return\n            }\n        } else if (routeSource.type === 'hashchange') { // A URL Hash change event\n            // console.log(`[uibrouter:doRoute] hashchange: ${this.keepHashFromUrl(routeSource.oldURL)} => ${this.keepHashFromUrl(routeSource.newURL)}. Current: ${currentHash}` )\n            const newUrl = routeSource.newURL\n            // Check if URL actually contains a #\n            if (newUrl.includes('#')) {\n                oldRouteId = this.keepHashFromUrl(routeSource.oldURL)\n                newRouteId = this.keepHashFromUrl(newUrl) // Only keep anything after the # & ignoring query params\n            } else return\n        } else { // A mouse click/touch event on a dom element with an href attribute\n            oldRouteId = currentHash\n            // Try to get the route name from the URL hash\n            try {\n                newRouteId = this.keepHashFromUrl(routeSource.target.attributes.href.value) // Only keep anything after the # & ignoring query params\n            } catch (e) {\n                throw new Error('[uibrouter:doRoute] No valid route found. Event.target does not have an href attribute')\n            }\n        }\n\n        let routeShown = false\n\n        // If no defined valid route, undo and report error\n        // If no defined valid route, undo and report error\n        if (!newRouteId || !this.routeIds.has(newRouteId)) {\n            // Events on route change fail ...\n            document.dispatchEvent(new CustomEvent('uibrouter:route-change-failed', { detail: { newRouteId, oldRouteId } }))\n            if (uibuilder) uibuilder.set('uibrouter', 'route change failed') // eslint-disable-line no-undef\n\n            // If the same, this happened on load and would keep failing so revert to default\n            if (newRouteId === oldRouteId) oldRouteId = ''\n            // Revert route\n            this.doRoute(oldRouteId || '')\n\n            // Don't throw an error here, it stops the menu highlighting from working\n            console.error(`[uibrouter:doRoute] No valid route found. Either pass a valid route name or an event from an element having an href of '#${newRouteId}'. Route id requested: '${newRouteId}'`)\n            return\n            // If the same, this happened on load and would keep failing so revert to default\n            if (newRouteId === oldRouteId) oldRouteId = ''\n            // Revert route\n            this.doRoute(oldRouteId || '')\n\n            // Don't throw an error here, it stops the menu highlighting from working\n            console.error(`[uibrouter:doRoute] No valid route found. Either pass a valid route name or an event from an element having an href of '#${newRouteId}'. Route id requested: '${newRouteId}'`)\n            return\n        }\n\n        // If requested (default), unload the old route template\n        if (this.config.templateUnload) this.unloadTemplate(oldRouteId)\n\n        // Show the new container (replace or show)\n        if (this.config.hide) {\n            // config.hide = true so hide previous contents\n            if (oldRouteId) {\n                /** @type {HTMLElement|null} */\n                const oldContent = document.querySelector(`div[data-route=\"${oldRouteId}\"]`)\n                if (oldContent) oldContent.style.display = 'none'\n            }\n            /** and unhide new route if possible @type {HTMLElement|null} */\n            const content = document.querySelector(`div[data-route=\"${newRouteId}\"]`)\n            if (content) {\n                content.style.removeProperty('display')\n                routeShown = true\n            } else {\n                // else create new content from template\n                try {\n                    routeShown = await this._createRouteContent(newRouteId)\n                } catch (e) {\n                    console.error('[uibrouter:doRRoute] ', e)\n                    routeShown = false\n                }\n            }\n        } else {\n            // config.hide != true so remove previous contents\n            container.replaceChildren()\n            // Create new content from template\n            try {\n                routeShown = await this._createRouteContent(newRouteId)\n            } catch (e) {\n                console.error('[uibrouter:doRRoute] ', e)\n                routeShown = false\n            }\n        }\n\n        // console.log({ newRouteId, oldRouteId, currentHash, routeShown })\n\n        // Roll back the route change if the new route cannot be shown\n        if (routeShown === false) {\n            // Events on route change fail ...\n            document.dispatchEvent(new CustomEvent('uibrouter:route-change-failed', { detail: { newRouteId, oldRouteId } }))\n            if (uibuilder) uibuilder.set('uibrouter', 'route change failed') // eslint-disable-line no-undef\n\n            window.location.hash = oldRouteId ? `#${oldRouteId}` : ''\n            return\n        }\n\n        // Retain current and previous route id's\n        this.currentRouteId = newRouteId\n        this.previousRouteId = oldRouteId\n\n        // Record the current route on the route container\n        container.dataset.currentRoute = newRouteId\n\n        // Update any existing HTML menu items\n        this.setCurrentMenuItems()\n\n        // Events on route changed ...\n        document.dispatchEvent(new CustomEvent('uibrouter:route-changed', { detail: { newRouteId, oldRouteId } }))\n        if (uibuilder) {\n            uibuilder.set('uibrouter', 'route changed')\n            uibuilder.set('uibrouter_CurrentRoute', newRouteId)\n            uibuilder.set('uibrouter_CurrentTitle', this.routeTitle())\n            uibuilder.set('uibrouter_CurrentDescription', this.routeDescription())\n            uibuilder.set('uibrouter_CurrentDetails', this.getRouteConfigById(newRouteId))\n        }\n    }\n\n    /** Return a route config given a route id (returns undefined if route not found)\n     * @param {string} routeId Route ID to search for\n     * @returns {routeDefinition|undefined} Route config for found id else undefined\n     */\n    getRouteConfigById(routeId) {\n        return Object.values(this.config.routes).filter(r => r.id === routeId)[0]\n    }\n\n    /** Return true if the given route is external, false otherwise\n     * Used to correctly (re)apply script tags when cloning the template to the DOM (createRouteContent)\n     * @param {string} routeId Route ID to check\n     * @returns {boolean} True if the given route is external, false otherwise\n     */\n    isRouteExternal(routeId) {\n        const routeConfig = this.getRouteConfigById(routeId)\n        return !!(routeConfig && routeConfig.type === 'url')\n    }\n\n    /** Go to the default route if it has been specified */\n    defaultRoute() {\n        if (this.config.defaultRoute) this.doRoute(this.config.defaultRoute)\n    }\n\n    /** Remove the hash from the browser URL */\n    removeHash() {\n        history.pushState('', document.title, window.location.pathname + window.location.search)\n    }\n\n    /** Empty the current container and remove url hash - does not trigger a route change */\n    noRoute() {\n        this.removeHash()\n        this.routeContainerEl.replaceChildren()\n    }\n\n    /** Only keep anything after the # & ignoring query params\n     * @param {string} url URL to extract the hash from\n     * @returns {string} Just the route id\n     */\n    keepHashFromUrl(url) {\n        if (!url) return ''\n        return url.replace(/^.*#(.*)/, '$1').replace(/\\?.*$/, '')\n    }\n\n    /** Return an array of route ids (to facilitate creation of menus)\n     * @param {boolean} returnHash If true, returns id's with leading `#` to apply to href attributes else returns the id\n     * @returns {string[]} Array of route id's or route url hashes\n     */\n    routeList(returnHash) {\n        if (returnHash === true) return this.routeIds.map((r) => returnHash === true ? `#${r.id}` : r.id)\n        return this.routeIds\n    }\n\n    /** Add new route definitions to the existing ones\n     * @param {routeDefinition|routeDefinition[]} routeDefn Single or array of route definitions to add\n     */\n    addRoutes(routeDefn) {\n        if (!Array.isArray(routeDefn)) routeDefn = [routeDefn]\n\n        if (this.config.templateLoadAll === false) {\n            // Only need to load the route configs since templates will be lazy loaded\n            this.config.routes.push(...routeDefn)\n            // and update the routeIds list\n            this._updateRouteIds()\n            // Let everyone know it all finished\n            document.dispatchEvent(new CustomEvent('uibrouter:routes-added', { detail: routeDefn }))\n            if (uibuilder) uibuilder.set('uibrouter', 'routes added')\n        } else {\n            // Load all external route templates async in parallel - NB: Object.values works on both arrays and objects\n            Promise.allSettled(Object.values(routeDefn).filter(r => r.type && r.type === 'url').map(this._loadExternal))\n                .then( results => {\n                    results.filter( res => res.status === 'rejected').forEach(res => {\n                        console.error(res.reason)\n                    })\n                    // results.filter( res => res.status === 'fulfilled').forEach(res => {})\n\n                    // Everything is loaded that can be - Add new routes to config\n                    this.config.routes.push(...routeDefn)\n                    // and update the routeIds list\n                    this._updateRouteIds()\n                    // Let everyone know it all finished\n                    document.dispatchEvent(new CustomEvent('uibrouter:routes-added', { detail: routeDefn }))\n                    if (uibuilder) uibuilder.set('uibrouter', 'routes added')\n                    return true\n                })\n                .catch( reason => {\n                    console.error(reason)\n                })\n        }\n    }\n\n    /** Remove a template from the DOM (optionally external templates only)\n     * @param {string} routeId REQUIRED. The route id of the template to remove (templates are ID's by their route id)\n     * @param {boolean=} externalOnly OPTIONAL, default=true. If true only remove if routeId is an external template\n     */\n    unloadTemplate(routeId, externalOnly) {\n        if (!externalOnly) externalOnly = true\n        if (!routeId || !this.isRouteExternal(routeId)) return\n\n        if (externalOnly === true && !this.isRouteExternal(routeId)) return\n\n        // Try to get the template - if found delete it\n        const chkTemplate = document.querySelector(`#${routeId}`)\n        if (chkTemplate) chkTemplate.remove()\n    }\n\n    /** Remove ALL templates from the DOM (optionally external templates only)\n     * @param {Array<string>=} templateIds OPTIONAL, default=ALL. Array of template (route) id's to remove\n     * @param {boolean=} externalOnly OPTIONAL, default=true. If true only remove if routeId is an external template\n     */\n    deleteTemplates(templateIds, externalOnly) {\n        if (!externalOnly) externalOnly = true\n        if (!templateIds || templateIds === '*') templateIds = [...this.routeIds]\n\n        if (!Array.isArray(templateIds)) templateIds = [templateIds]\n\n        templateIds.forEach( routeId => {\n            if (externalOnly === true && !this.isRouteExternal(routeId)) return\n            console.log('delete', routeId, this.isRouteExternal(routeId), externalOnly)\n            this.unloadTemplate(routeId, externalOnly)\n        } )\n    }\n\n    //#region --- utils for page display & processing ---\n    setCurrentMenuItems() {\n        // const items = document.querySelectorAll(`li[data-route=\"${this.currentRouteId}\"]`)\n        const items = document.querySelectorAll('li[data-route]')\n        items.forEach( item => {\n            if (item.dataset.route === this.currentRouteId) {\n                item.classList.add('currentRoute')\n                item.setAttribute('aria-current', 'page')\n            } else {\n                item.classList.remove('currentRoute')\n                item.removeAttribute('aria-current')\n            }\n        })\n    }\n\n    routeTitle() {\n        const thisRoute = this.currentRoute() || {}\n        return thisRoute.title || thisRoute.id || '[ROUTE NOT FOUND]'\n    }\n\n    routeDescription() {\n        const thisRoute = this.currentRoute() || {}\n        return thisRoute.description || thisRoute.id || '[ROUTE NOT FOUND]'\n    }\n\n    currentRoute() {\n        return this.getRouteConfigById(this.currentRouteId)\n    }\n    //#endregion ---- ----- ----\n\n    // TODO\n    // deleteRoutes(aRoutes) {\n    //     // Delete all if no list provided\n    //     if (!aRoutes) aRoutes = this.config.routes\n    //     if (!Array.isArray(aRoutes)) aRoutes = [aRoutes]\n    //     console.log('to be deleted', this.config.routes.filter(r => aRoutes.includes(r.id)))\n    //     console.log('to be retained', this.config.routes.filter(r => !aRoutes.includes(r.id)))\n\n    //     // TODO actually remove the unwanted route templates\n    //     // TODO remove from the config: this.config.routes = this.config.routes.filter(r => !aRoutes.includes(r.id))\n\n    //     // ? Optional future upgrade - attempt to also remove any links to this route?\n    // }\n\n    // TODO\n    // reloadTemplates(templateIds) {\n    //     if (!Array.isArray(templateIds)) templateIds = [templateIds]\n    //     templateIds.forEach( templateid => {\n    //         // TODO reload\n    //     } )\n    // }\n} // ---- End of class ----\n\n// For use in ESM loads\nexport { UibRouter }\nexport default UibRouter\n\n// Auto-assign for when the library is loaded via a script tag\nif (!window['UibRouter']) {\n    window['UibRouter'] = UibRouter\n} else {\n    console.warn('`UibRouter` already assigned to window. Have you tried to load it more than once?')\n}\n"],
  "mappings": "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",
  "names": ["_startDone", "UibRouter", "routerConfig", "__publicField", "__privateAdd", "r", "results", "res", "reason", "body", "routeContainerEl", "tempContainer", "loadedElements", "head", "errors", "element", "__privateGet", "event", "__privateSet", "routeId", "rContent", "loadedEls", "e", "docFrag", "routeDefinition", "id", "response", "htmlText", "chkTemplate", "scr", "newScript", "routeSource", "container", "currentHash", "newRouteId", "oldRouteId", "newUrl", "routeShown", "oldContent", "content", "routeConfig", "url", "returnHash", "routeDefn", "externalOnly", "templateIds", "item", "thisRoute", "uibrouter_default", "UibRouter"]
}
