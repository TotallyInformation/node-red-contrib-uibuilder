{
  "version": 3,
  "sources": ["src/front-end-module/uibrouter.js"],
  "sourcesContent": ["/* eslint-disable no-undef, jsdoc/check-property-names */\n// @ts-nocheck\n/** A simple, vanilla JavaScript front-end router class\n * Included in node-red-contrib-uibuilder but is not dependent on it.\n * May be used in other contexts as desired.\n *\n * Copyright (c) 2023-2024 Julian Knight (Totally Information)\n * https://it.knightnet.org.uk\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Type definitions\n * routeDefinition\n * @typedef {object} routeDefinition Single route configuration\n * @property {string} id REQUIRED. Route ID\n * @property {string} src REQUIRED for external, optional for internal (default=route id). CSS Selector for template tag routes, url for external routes\n * @property {\"url\"|undefined} [type] OPTIONAL, default=internal route. \"url\" for external routes\n * @property {string} [title] OPTIONAL, default=route id. Text to use as a short title for the route\n * @property {string} [description] OPTIONAL, default=route id. Text to use as a long description for the route\n * @property {\"html\"|\"md\"|\"markdown\"} [format] OPTIONAL, default=html. Route content format, HTML or Markdown (md). Markdown requires the Markdown-IT library to have been loaded.\n *\n * UibRouterConfig\n * @typedef {object} UibRouterConfig Configuration for the UiBRouter class instances\n * @property {routeDefinition[]} routes REQUIRED. Array of route definitions\n * @property {Array<string|object>} [mdPlugins] OPTIONAL. Array of Markdown-IT plugins\n * @property {string} [defaultRoute] OPTIONAL, default=1st route. If set to a route id, that route will be automatically shown on load\n * @property {string} [routeContainer] OPTIONAL, default='#uibroutecontainer'. CSS Selector for an HTML Element containing routes\n * @property {boolean} [hide] OPTIONAL, default=false. If TRUE, routes will be hidden/shown on change instead of removed/added\n * @property {boolean} [templateLoadAll] OPTIONAL, default=false. If TRUE, all external route templates will be loaded when the router is instanciated. Default is to lazy-load external templates\n * @property {boolean} [templateUnload] OPTIONAL, default=true. If TRUE, route templates will be unloaded from DOM after access.\n * @property {otherLoadDefinition[]} [otherLoad] OPTIONAL, default=none. If present, router start will pre-load other external templates direct to the DOM. Use for menu's, etc.\n *\n * otherLoadDefinition\n * @typedef {object} otherLoadDefinition Single external load configuration\n * @property {string} id REQUIRED. Unique (to page) ID. Will be applied to loaded content.\n * @property {string} src REQUIRED. url of external template to load\n * @property {string} container REQUIRED. CSS Selector defining the parent element that this will become the child of. If it doesn't exist on page, content will not be loaded.\n */\n\nclass UibRouter { // eslint-disable-line no-unused-vars\n    //#region --- Variables ---\n    /** Class version */\n    static version = '1.4.0' // 2024-04-07\n    /** Ensures only 1 class instance on a page */\n    static #instanceExists = false\n    /** Options for Markdown-IT if available (set in constructor) */\n    static mdOpts\n    /** Reference to pre-loaded Markdown-IT library */\n    static md\n\n    /** Configuration settings @type {UibRouterConfig} */\n    config\n    /** Reference to the container DOM element - set in setup() @type {HTMLDivElement} */\n    routeContainerEl\n    /** The current route id after doRoute() has been called */\n    currentRouteId\n    /** The previous route id after doRoute() has been called */\n    previousRouteId\n    /** Array of route ID's (created in constructor) */\n    routeIds = []\n\n    /** Internal only. Set to true when the _start() method has been called */\n    #startDone = false\n\n    safety = 0\n    uibuilder = false\n    //#endregion --- ----- ---\n\n    //#region --- Internal Methods ---\n    /** Class constructor\n     * @param {UibRouterConfig} routerConfig Configuration object\n     */\n    constructor(routerConfig) {\n        // Enforce only 1 instance on page (otherwise uibuilder vars will be overwritten)\n        if (UibRouter.#instanceExists) throw new Error('[uibrouter:constructor] Only 1 instance of a UibRouter may exist on the page.')\n\n        // Fetch is on desktop browsers since 2017 at least. Not so much on mobile (Android!)\n        // May need a polyfill on mobile or old browsers.\n        if (!fetch) throw new Error('[uibrouter:constructor] UibRouter requires `fetch`. Please use a current browser or load a fetch polyfill.')\n\n        if (!routerConfig) throw new Error('[uibrouter:constructor] No config provided')\n        if (!routerConfig.routes) throw new Error('[uibrouter:constructor] No routes provided in routerConfig')\n\n        // Save the config\n        this.config = routerConfig\n\n        // Add a default route container uf needed\n        if (!this.config.routeContainer) this.config.routeContainer = '#uibroutecontainer'\n        // If no default set in config, set to the first entry\n        if (!this.config.defaultRoute && this.config.routes[0] && this.config.routes[0].id) this.config.defaultRoute = this.config.routes[0].id\n        // Other defaults\n        if (!this.config.hide) this.config.hide = false\n        if (!this.config.templateLoadAll) this.config.templateLoadAll = false\n        if (!this.config.templateUnload) this.config.templateUnload = true\n\n        this._normaliseRouteDefns(this.config.routes)\n\n        // If Markdown-IT library pre-loaded, set it up now\n        if (window['markdownit']) this._markdownIt()\n\n        if (window['uibuilder']) {\n            this.uibuilder = true\n            uibuilder.set('uibrouterinstance', this)\n        }\n\n        // Create/access the route container element, sets this.routeContainerEl\n        this._setRouteContainer()\n\n        if (this.config.otherLoad) this.loadOther(this.config.otherLoad)\n\n        this._updateRouteIds()\n\n        // Only pre-load all templates if requested (default is not to)\n        if (this.config.templateLoadAll === false) {\n            this._start()\n        } else {\n            console.info('[uibrouter] Pre-loading all external templates')\n            // Load all external route templates async in parallel - NB: Object.values works on both arrays and objects\n            // Note that final `then` is called even if no external routes are given\n            Promise.allSettled(Object.values(routerConfig.routes).filter(r => r.type && r.type === 'url').map(this._loadExternal))\n                .then( results => {\n                    results.filter( res => res.status === 'rejected').forEach(res => {\n                        console.error(res.reason)\n                    })\n                    results.filter( res => res.status === 'fulfilled').forEach(res => {\n                        console.log('allSettled results', res, results)\n                        this._appendExternalTemplates(res.value)\n                    })\n                    // Everything is loaded that can be so we can start\n                    this._start()\n                    return true\n                })\n                .catch( reason => {\n                    console.error(reason)\n                })\n        }\n\n        UibRouter.#instanceExists = true\n    }\n\n    /** Save a reference to, and create if necessary, the HTML element to hold routes */\n    _setRouteContainer() {\n        const body = document.getElementsByTagName('body')[0]\n        // Get reference to route container or create it\n        let routeContainerEl = this.routeContainerEl = document.querySelector(this.config.routeContainer)\n        if (!routeContainerEl) {\n            // throw new Error(`Route container element with CSS selector '${routerConfig.routeContainer}' not found in HTML`)\n            const tempContainer = document.createElement('div')\n            tempContainer.setAttribute('id', this.config.routeContainer.replace('#', ''))\n            body.append(tempContainer)\n            routeContainerEl = this.routeContainerEl = document.querySelector(this.config.routeContainer)\n        }\n    }\n\n    /** Apply fetched external elements to templates tags under the head tag\n     * @param {HTMLElement[]} loadedElements Array of loaded external elements to add as templates to the head tag\n     * @returns {number} Count of load errors\n     */\n    _appendExternalTemplates(loadedElements) {\n        if (!Array.isArray(loadedElements)) loadedElements = [loadedElements]\n        // console.log('_appendExternalTemplates', loadedElements)\n        const head = document.getElementsByTagName('head')[0]\n        let errors = 0\n        // Append the loaded content to the main container\n        loadedElements.forEach(element => {\n            if (Array.isArray(element)) {\n                console.error(...element)\n                errors++\n            } else {\n                head.append(element)\n            }\n        })\n        return errors\n    }\n\n    /** Called once all external templates have been loaded */\n    async _start() {\n        if (this.#startDone === true) return // Don't run this again\n\n        // Go to url hash route or default route if no route in url\n        await this.doRoute(this.keepHashFromUrl(window.location.hash))\n\n        // After initial route set, listen for url hash changes and process route change\n        window.addEventListener('hashchange', (event) => this._hashChange(event) )\n\n        // Events on fully loaded ...\n        document.dispatchEvent(new CustomEvent('uibrouter:loaded'))\n        if (this.uibuilder) uibuilder.set('uibrouter', 'loaded') // eslint-disable-line no-undef\n\n        this.#startDone = true // Don't run this again\n    }\n\n    /** Called when the URL Hash changes\n     * @param {HashChangeEvent} event URL Hash change event object\n     */\n    _hashChange(event) {\n        // console.log(`[uibrouter] hashchange: ${this.keepHashFromUrl(event.oldURL)} => ${this.keepHashFromUrl(event.newURL)}` )\n        this.doRoute(event)\n    }\n\n    /** Loads an external HTML file into a `<template>` tag, adding the router id as the template id. Or throws.\n     * @param {routeDefinition} routeDefinition Configuration for a single route\n     * @returns {HTMLTemplateElement[]} An HTMLTemplateElement that will provide the route content\n     */\n    async _loadExternal(routeDefinition) {\n        if (!routeDefinition) throw new Error('[uibrouter:loadExternal] Error loading route template. No route definition provided.')\n        // Obviously, this only works for internal routes\n        if (!routeDefinition.src) {\n            if (!routeDefinition.type || (routeDefinition.type && routeDefinition.type !== 'url')) routeDefinition.src = routeDefinition.id\n            else throw new Error('[uibrouter:loadExternal] Error loading route template. `src` property not defined')\n        }\n\n        const id = routeDefinition.id\n\n        let response\n        try {\n            response = await fetch(routeDefinition.src)\n        } catch (e) {\n            throw new Error(`[uibrouter:loadExternal] Error loading route template HTML for route: ${routeDefinition.id}, src: ${routeDefinition.src}. Error: ${e.message}`, e)\n        }\n\n        // Fetch failed?\n        if (response.ok === false) throw new Error(`[uibrouter:loadExternal] Fetch failed to return data for route: ${routeDefinition.id}, src: ${routeDefinition.src}. Status: ${response.statusText} (${response.status})`, [routeDefinition.id, routeDefinition.src, response.status, response.statusText])\n\n        /** @type {string & any[]} */\n        let htmlText = await response.text()\n\n        // If Markdown & library loaded, convert from markdown to HTML\n        if (window['markdownit'] && routeDefinition.format === 'md') {\n            htmlText = this.renderMarkdown(htmlText)\n        }\n\n        // Check to see if template already exists, if so, remove it\n        try {\n            const chkTemplate = document.querySelector(`#${id}`)\n            if (chkTemplate) chkTemplate.remove()\n        } catch (e) {}\n\n        // Return the template\n        const tempContainer = document.createElement('template')\n        tempContainer.innerHTML = htmlText\n        tempContainer.setAttribute('id', id)\n        return tempContainer\n    }\n\n    /** Remove/re-apply scripts in a container Element so that they are executed.\n     * @param {HTMLElement} tempContainer HTML Element of container to process\n     */\n    _applyScripts(tempContainer) {\n        const scripts = tempContainer.querySelectorAll('script')\n        scripts.forEach( scr => {\n            const newScript = document.createElement('script')\n            newScript.textContent = scr.innerText\n            tempContainer.append(newScript)\n            scr.remove() // remove the origin\n        })\n    }\n\n    /** Set up the MarkdownIT library if loaded */\n    _markdownIt() {\n        if (!window['markdownit']) return\n        // If plugins not yet defined, check if uibuilder has set them\n        if (!this.config.mdPlugins && window['uibuilder'] && window['uibuilder'].ui_md_plugins) this.config.mdPlugins = window['uibuilder'].ui_md_plugins\n        // If Markdown-IT library pre-loaded, set it up now\n        UibRouter.mdOpts = {\n            html: true,\n            xhtmlOut: false,\n            linkify: true,\n            _highlight: true,\n            _strict: false,\n            _view: 'html',\n            langPrefix: 'language-',\n            // NB: the highlightjs (hljs) library must be loaded before markdown-it for this to work\n            highlight: function(str, lang) {\n                if (window['hljs']) {\n                    if (lang && window['hljs'].getLanguage(lang)) {\n                        try {\n                            return `<pre><code class=\"hljs border language-${lang}\" data-language=\"${lang}\" title=\"Source language: '${lang}'\">${window['hljs'].highlight(str, { language: lang, ignoreIllegals: true }).value}</code></pre>`\n                        } finally { } // eslint-disable-line no-empty\n                    } else {\n                        try {\n                            const high = window['hljs'].highlightAuto(str)\n                            return `<pre><code class=\"hljs border language-${high.language}\" data-language=\"${high.language}\" title=\"Source language estimated by HighlightJS: '${high.language}'\">${high.value}</code></pre>`\n                        } finally { } // eslint-disable-line no-empty\n                    }\n                }\n                return `<pre><code class=\"border\">${Ui.md.utils.escapeHtml(str).trim()}</code></pre>`\n            },\n        }\n        UibRouter.md = window['markdownit'](UibRouter.mdOpts)\n        if (this.config.mdPlugins) {\n            if (!Array.isArray(this.config.mdPlugins)) {\n                console.error('[uibrouter:_markDownIt:plugins] Could not load plugins, config.mdPlugins is not an array')\n                return\n            }\n            this.config.mdPlugins.forEach( plugin => {\n                if (typeof plugin === 'string') {\n                    UibRouter.md.use(window[plugin])\n                } else {\n                    const name = Object.keys(plugin)[0]\n                    UibRouter.md.use(window[name], plugin[name])\n                }\n            })\n        }\n    }\n\n    /** Normalise route definition arrays\n     * @param {Array<routeDefinition>} routeDefns Route definitions to normalise\n     */\n    _normaliseRouteDefns(routeDefns) {\n        if (!Array.isArray(routeDefns)) routeDefns = [routeDefns]\n        routeDefns.forEach( defn => {\n            let fmt = defn.format || 'html'\n            fmt = fmt.toLowerCase()\n            if (fmt === 'markdown') fmt = 'md'\n            defn.format = fmt\n        })\n    }\n\n    /** Update this.routeIds array from this.config (on start and after add/remove routes) */\n    _updateRouteIds() {\n        this.routeIds = new Set(Object.values(this.config.routes).map( r => r.id ))\n    }\n\n    /** If uibuilder in use, report on route change\n     * @param {string} newRouteId The route id now shown\n     */\n    _uibRouteChange(newRouteId) {\n        if (!this.uibuilder || !newRouteId) return\n        uibuilder.set('uibrouter', 'route changed')\n        uibuilder.set('uibrouter_CurrentRoute', newRouteId)\n        uibuilder.set('uibrouter_CurrentTitle', this.routeTitle())\n        uibuilder.set('uibrouter_CurrentDescription', this.routeDescription())\n        uibuilder.set('uibrouter_CurrentDetails', this.getRouteConfigById(newRouteId))\n        // Send control msg back to Node-RED\n        uibuilder.sendCtrl({\n            uibuilderCtrl: 'route change',\n            routeId: newRouteId,\n            title: this.routeTitle(),\n            description: this.routeDescription(),\n            details: this.getRouteConfigById(newRouteId),\n        })\n    }\n    //#endregion --- ----- --\n\n    /** Process a routing request\n     * All errors throw so make sure to try/catch calls to this method.\n     * @param {PointerEvent|MouseEvent|HashChangeEvent|TouchEvent|string} routeSource Either string containing route id or DOM Event object either click/touch on element containing `href=\"#routeid\"` or Hash URL change event\n     */\n    async doRoute(routeSource) {\n        if (this.safety > 10) throw new Error('\uD83D\uDEAB [uibrouter:doRoute] Safety protocol triggered, too many route bounces')\n\n        // If no routes at all, just exit (maybe they will be loaded later)\n        if (!this.config.routes || this.config.routes < 1) return\n\n        if (!routeSource) routeSource = this.config.defaultRoute\n\n        const container = this.routeContainerEl\n        if (!container) throw new Error('[uibrouter:doRoute] Cannot route, has router.setup() been called yet?')\n\n        // Remove all the url and query param text and any leading # - returns '' if no current hash\n        const currentHash = this.keepHashFromUrl(window.location.hash)\n\n        // If no route source provided, take the current hash (which might be '' and that will trigger the default route if defined)\n        if (!routeSource) routeSource = currentHash\n\n        let newRouteId, oldRouteId\n\n        // Define new and old routes depending on different call types\n        if (typeof routeSource === 'string') { // Manually provided route id\n            // console.log(`[uibrouter:doRoute] manual: ${currentHash} => ${this.keepHashFromUrl(routeSource)}. Current: ${currentHash}` )\n            newRouteId = this.keepHashFromUrl(routeSource)\n            oldRouteId = currentHash\n            // If no hash & config has default, set the default as new\n            if (newRouteId === '' && this.config.defaultRoute) newRouteId = this.config.defaultRoute\n            // If the new route id not the same as the current one in the url hash, just change the current hash & exit\n            if (newRouteId !== currentHash ) {\n                window.location.hash = `#${newRouteId}`\n                return\n            }\n        } else if (routeSource.type === 'hashchange') { // A URL Hash change event\n            // console.log(`[uibrouter:doRoute] hashchange: ${this.keepHashFromUrl(routeSource.oldURL)} => ${this.keepHashFromUrl(routeSource.newURL)}. Current: ${currentHash}` )\n            const newUrl = routeSource.newURL\n            // Check if URL actually contains a #\n            if (newUrl.includes('#')) {\n                oldRouteId = this.keepHashFromUrl(routeSource.oldURL)\n                newRouteId = this.keepHashFromUrl(newUrl) // Only keep anything after the # & ignoring query params\n            } else return\n        } else { // A mouse click/touch event on a dom element with an href attribute\n            oldRouteId = currentHash\n            // Try to get the route name from the URL hash\n            try {\n                newRouteId = this.keepHashFromUrl(routeSource.target.attributes.href.value) // Only keep anything after the # & ignoring query params\n            } catch (e) {\n                throw new Error('[uibrouter:doRoute] No valid route found. Event.target does not have an href attribute')\n            }\n        }\n\n        let routeShown = false\n\n        // If no defined valid route id, undo and report error\n        if (!newRouteId || !this.routeIds.has(newRouteId)) {\n            // Events on route change fail ...\n            document.dispatchEvent(new CustomEvent('uibrouter:route-change-failed', { detail: { newRouteId, oldRouteId } }))\n            if (this.uibuilder) uibuilder.set('uibrouter', 'route change failed') // eslint-disable-line no-undef\n            // If ID's the same, this happened on load and would keep failing so revert to default\n            if (newRouteId === oldRouteId) oldRouteId = ''\n            // Don't throw an error here, it stops the menu highlighting from working\n            console.error(`[uibrouter:doRoute] No valid route found. Either pass a valid route name or an event from an element having an href of '#${newRouteId}'. Route id requested: '${newRouteId}'`)\n            this.safety++\n            // Revert route\n            this.doRoute(oldRouteId || '')\n            return\n        }\n\n        // At this point, we have a valid route ID\n\n        // NB: The `loadRoute` method will attempt to load external templates that are not currently loaded\n\n        // Show the new container (replace or show)\n        if (this.config.hide) {\n            // config.hide = true so hide previous contents\n            if (oldRouteId) {\n                /** @type {HTMLElement|null} */\n                const oldContent = document.querySelector(`div[data-route=\"${oldRouteId}\"]`)\n                if (oldContent) oldContent.style.display = 'none'\n            }\n            /** and unhide new route if possible @type {HTMLElement|null} */\n            const content = document.querySelector(`div[data-route=\"${newRouteId}\"]`)\n            if (content) {\n                content.style.removeProperty('display')\n                routeShown = true\n            } else {\n                // else create new content from template\n                try {\n                    routeShown = await this.loadRoute(newRouteId)\n                } catch (e) {\n                    console.error('[uibrouter:doRoute] ', e)\n                    routeShown = false\n                }\n            }\n        } else {\n            // config.hide != true so remove previous contents\n            container.replaceChildren()\n            // Create new content from template\n            try {\n                routeShown = await this.loadRoute(newRouteId)\n            } catch (e) {\n                console.error('[uibrouter:doRoute] ', e)\n                routeShown = false\n            }\n        }\n\n        // console.log({ newRouteId, oldRouteId, currentHash, routeShown })\n\n        // Roll back the route change if the new route cannot be shown\n        if (routeShown === false) {\n            // Events on route change fail ...\n            document.dispatchEvent(new CustomEvent('uibrouter:route-change-failed', { detail: { newRouteId, oldRouteId } }))\n            if (this.uibuilder) uibuilder.set('uibrouter', 'route change failed') // eslint-disable-line no-undef\n            // If ID's the same, this happened on load and would keep failing so revert to default\n            if (newRouteId === oldRouteId) oldRouteId = ''\n            // Don't throw an error here, it stops the menu highlighting from working\n            console.error(`[uibrouter:doRoute] Route content for '${newRouteId}' could not be shown, reverting to old route '${oldRouteId}'`)\n            this.safety++\n            // Revert route\n            this.doRoute(oldRouteId || '')\n            return\n        }\n\n        // At this point, the new route has successfully been shown\n        this.safety = 0\n\n        // If requested (default), unload the old route template\n        if (this.config.templateUnload) this.unloadTemplate(oldRouteId)\n\n        // Retain current and previous route id's\n        this.currentRouteId = newRouteId\n        this.previousRouteId = oldRouteId\n\n        // Record the current route on the route container\n        container.dataset.currentRoute = newRouteId\n\n        // Update any existing HTML menu items\n        this.setCurrentMenuItems()\n\n        // Events on route changed ...\n        document.dispatchEvent(new CustomEvent('uibrouter:route-changed', { detail: { newRouteId, oldRouteId } }))\n        this._uibRouteChange(newRouteId)\n    }\n\n    /** Load other external files and apply to specific parents (mostly used for externally defined menus)\n     * @param {otherLoadDefinition|Array<otherLoadDefinition>} extOther Required. Array of objects defining what to load and where\n     */\n    loadOther(extOther) {\n        if (!extOther) throw new Error('[uibrouter:loadOther] At least 1 load definition must be provided')\n        if (!Array.isArray(extOther)) extOther = [extOther]\n\n        extOther.forEach( async f => {\n            const parent = document.querySelector(f.container)\n            if (!parent) return // Nothing to do if parent does not exist on page\n\n            let response\n            try {\n                response = await fetch(f.src)\n            } catch (e) {\n                throw new Error(`[uibrouter:loadOther] Error loading template HTML for '${f.id}', src: '${f.src}'. Error: ${e.message}`, e)\n            }\n            // Fetch failed?\n            if (response.ok === false) throw new Error(`[uibrouter:loadOther] Fetch failed to return data '${f.id}', src: '${f.src}'. Status: ${response.statusText} (${response.status})`, [f.id, f.src, response.status, response.statusText])\n\n            /** @type {string & any[]} */\n            const htmlText = await response.text()\n\n            // We fetched it, so now load it to the DOM\n            const tempContainer = document.createElement('div')\n            tempContainer.innerHTML = htmlText\n            tempContainer.id = f.id\n\n            parent.append(tempContainer)\n            this._applyScripts(parent.lastChild)\n        })\n    }\n\n    /** Async method to create DOM route content from a route template (internal or external) - loads external templates if not already loaded\n     * Route templates have to be a `<template>` tag with an ID that matches the route id.\n     * Scripts in the template are run at this point.\n     * All errors throw so make sure to try/catch calls to this method.\n     * @param {string} routeId ID of the route definition to use to create the content\n     * @param {HTMLElement} [routeParentEl] OPTIONAL, default=this.routeContainerEl (master route container). Reference to an HTML Element to which the route content will added as a child.\n     * @returns {boolean} True if the route content was created successfully, false otherwise\n     */\n    async loadRoute(routeId, routeParentEl) {\n        if (!routeParentEl) routeParentEl = this.routeContainerEl\n\n        // Try to reference the template for this route\n        let rContent\n        try {\n            rContent = await this.ensureTemplate(routeId)\n        } catch (e) {\n            throw new Error(`[uibrouter:loadRoute] No template for route id '${routeId}'. \\n ${e.message}`)\n        }\n\n        // Clone the template\n        const docFrag = rContent.content.cloneNode(true)\n\n        // Have to re-apply the scripts to make them run - only for external templates\n        if (this.isRouteExternal(routeId)) this._applyScripts(docFrag)\n\n        // Create the route wrapper div with data-route attrib\n        const tempContainer = document.createElement('div')\n        tempContainer.dataset.route = routeId\n        tempContainer.append(docFrag)\n\n        // And finally try to append to the container\n        try {\n            routeParentEl.append(tempContainer)\n        } catch (e) {\n            throw new Error(`[uibrouter:loadRoute] Failed to apply route id '${routeId}'. \\n ${e.message}`)\n        }\n\n        // Then tell the world\n        document.dispatchEvent(new CustomEvent('uibrouter:route-loaded', { routeId: routeId }))\n\n        // If we get here, everything is good\n        return true\n    }\n\n    /** Async method to ensure that a template element exists for a given route id\n     *  If route is external, will try to load if it doesn't exist.\n     * All errors throw so make sure to try/catch calls to this method.\n     * @param {string} routeId A single route ID\n     * @returns {HTMLTemplateElement} A reference to the HTML Template element\n     */\n    async ensureTemplate(routeId) {\n        if (!routeId || !this.routeIds.has(routeId)) throw new Error(`[uibrouter:ensureTemplate] No valid route id provided. Route ID: '${routeId}'`)\n        // Try to reference the template for this route\n        let rContent = document.querySelector(`#${routeId}`)\n        // If not found, try once to load it - assuming it is external\n        if (!rContent) {\n            // If external template content doesn't exist, try to load it now (but only try once)\n            const r = this.getRouteConfigById(routeId)\n            if (r.type && r.type === 'url') {\n                let loadedEls\n                try {\n                    loadedEls = await this._loadExternal(r)\n                } catch (e) {\n                    throw new Error(e.message, e)\n                }\n\n                if (!loadedEls) throw new Error(`[uibrouter:ensureTemplate] No route template found for route selector '#${routeId}'. Does the link url match a defined route id?`)\n\n                // Apply fetched external elements to templates tags under the head tag\n                this._appendExternalTemplates(loadedEls)\n\n                // And check that the template now actually exists\n                rContent = document.querySelector(`#${routeId}`)\n\n                if (!rContent) throw new Error(`[uibrouter:ensureTemplate] No valid route template found for external route selector '#${routeId}'`)\n            } else {\n                // type not not external so we can't do anything when it doesn't actually exist\n                throw new Error(`[uibrouter:ensureTemplate] No route template found for internal route selector '#${routeId}'. Ensure that a template element with the matching ID exists in the HTML.`)\n            }\n        }\n        return rContent\n    }\n\n    /** Return a route config given a route id (returns undefined if route not found)\n     * @param {string} routeId Route ID to search for\n     * @returns {routeDefinition|undefined} Route config for found id else undefined\n     */\n    getRouteConfigById(routeId) {\n        return Object.values(this.config.routes).filter(r => r.id === routeId)[0]\n    }\n\n    /** Return true if the given route is external, false otherwise\n     * Used to correctly (re)apply script tags when cloning the template to the DOM (createRouteContent)\n     * @param {string} routeId Route ID to check\n     * @returns {boolean} True if the given route is external, false otherwise\n     */\n    isRouteExternal(routeId) {\n        const routeConfig = this.getRouteConfigById(routeId)\n        return !!(routeConfig && routeConfig.type === 'url')\n    }\n\n    /** Go to the default route if it has been specified */\n    defaultRoute() {\n        if (this.config.defaultRoute) this.doRoute(this.config.defaultRoute)\n    }\n\n    /** Remove the hash from the browser URL */\n    removeHash() {\n        history.pushState('', document.title, window.location.pathname + window.location.search)\n    }\n\n    /** Empty the current container and remove url hash - does not trigger a route change */\n    noRoute() {\n        this.removeHash()\n        this.routeContainerEl.replaceChildren()\n    }\n\n    /** Only keep anything after the # & ignoring query params\n     * @param {string} url URL to extract the hash from\n     * @returns {string} Just the route id\n     */\n    keepHashFromUrl(url) {\n        if (!url) return ''\n        return url.replace(/^.*#(.*)/, '$1').replace(/\\?.*$/, '')\n    }\n\n    /** Return an array of route ids (to facilitate creation of menus)\n     * @param {boolean} returnHash If true, returns id's with leading `#` to apply to href attributes else returns the id\n     * @returns {string[]} Array of route id's or route url hashes\n     */\n    routeList(returnHash) {\n        if (returnHash === true) return this.routeIds.map((r) => returnHash === true ? `#${r.id}` : r.id)\n        return this.routeIds\n    }\n\n    /** Add new route definitions to the existing ones\n     * @param {routeDefinition|routeDefinition[]} routeDefn Single or array of route definitions to add\n     */\n    addRoutes(routeDefn) {\n        if (!Array.isArray(routeDefn)) routeDefn = [routeDefn]\n        this._normaliseRouteDefns(routeDefn)\n\n        // Update the route config\n        this.config.routes.push(...routeDefn)\n        // and update the routeIds list\n        this._updateRouteIds()\n        // Let everyone know it all finished\n        document.dispatchEvent(new CustomEvent('uibrouter:routes-added', { detail: routeDefn }))\n        if (this.uibuilder) uibuilder.set('uibrouter', 'routes added')\n\n        if (this.config.templateLoadAll) {\n            // Load all external route templates async in parallel - NB: Object.values works on both arrays and objects\n            Promise.allSettled(Object.values(routeDefn).filter(r => r.type && r.type === 'url').map(this._loadExternal))\n                .then( results => {\n                    results.filter( res => res.status === 'rejected').forEach(res => {\n                        console.error(res.reason)\n                    })\n                    // results.filter( res => res.status === 'fulfilled').forEach(res => {})\n\n                    // Everything is loaded that can be - Add new routes to config\n                    this.config.routes.push(...routeDefn)\n                    // and update the routeIds list\n                    this._updateRouteIds()\n                    // Let everyone know it all finished\n                    document.dispatchEvent(new CustomEvent('uibrouter:routes-added', { detail: routeDefn }))\n                    if (this.uibuilder) uibuilder.set('uibrouter', 'routes added')\n                    return true\n                })\n                .catch( reason => {\n                    console.error(reason)\n                })\n        }\n    }\n\n    /** Remove a template from the DOM (optionally external templates only)\n     * @param {string} routeId REQUIRED. The route id of the template to remove (templates are ID's by their route id)\n     * @param {boolean=} externalOnly OPTIONAL, default=true. If true only remove if routeId is an external template\n     */\n    unloadTemplate(routeId, externalOnly) {\n        if (!externalOnly) externalOnly = true\n        if (!routeId || !this.isRouteExternal(routeId)) return\n\n        if (externalOnly === true && !this.isRouteExternal(routeId)) return\n\n        // Try to get the template - if found delete it\n        const chkTemplate = document.querySelector(`#${routeId}`)\n        if (chkTemplate) chkTemplate.remove()\n    }\n\n    /** Remove ALL templates from the DOM (optionally external templates only)\n     * @param {Array<string>=} templateIds OPTIONAL, default=ALL. Array of template (route) id's to remove\n     * @param {boolean=} externalOnly OPTIONAL, default=true. If true only remove if routeId is an external template\n     */\n    deleteTemplates(templateIds, externalOnly) {\n        if (!externalOnly) externalOnly = true\n        if (!templateIds || templateIds === '*') templateIds = [...this.routeIds]\n\n        if (!Array.isArray(templateIds)) templateIds = [templateIds]\n\n        templateIds.forEach( routeId => {\n            if (externalOnly === true && !this.isRouteExternal(routeId)) return\n            this.unloadTemplate(routeId, externalOnly)\n        } )\n    }\n\n    //#region --- utils for page display & processing ---\n    setCurrentMenuItems() {\n        // const items = document.querySelectorAll(`li[data-route=\"${this.currentRouteId}\"]`)\n        const items = document.querySelectorAll('li[data-route]')\n        items.forEach( item => {\n            if (item.dataset.route === this.currentRouteId) {\n                item.classList.add('currentRoute')\n                item.setAttribute('aria-current', 'page')\n            } else {\n                item.classList.remove('currentRoute')\n                item.removeAttribute('aria-current')\n            }\n        })\n    }\n\n    routeTitle() {\n        const thisRoute = this.currentRoute() || {}\n        return thisRoute.title || thisRoute.id || '[ROUTE NOT FOUND]'\n    }\n\n    routeDescription() {\n        const thisRoute = this.currentRoute() || {}\n        return thisRoute.description || thisRoute.id || '[ROUTE NOT FOUND]'\n    }\n\n    currentRoute() {\n        return this.getRouteConfigById(this.currentRouteId)\n    }\n\n    /** Use Markdown-IT to render Markdown to HTML\n     * https://markdown-it.github.io/markdown-it\n     * @param {string} mdText Markdown string\n     * @returns {string|undefined} HTML rendering of the Markdown input\n     */\n    renderMarkdown(mdText) {\n        if (!window['markdownit']) return\n        if (!UibRouter.md) this._markdownIt() // In case Markdown-IT lib was late loaded\n        try {\n            return UibRouter.md.render(mdText.trim())\n        } catch (e) {\n            console.error(`[uibrouter:renderMarkdown] Could not render Markdown. ${e.message}`, e)\n            return '<p class=\"border error\">Could not render Markdown<p>'\n        }\n    }\n    //#endregion ---- ----- ----\n\n    // TODO\n    // deleteRoutes(aRoutes) {\n    //     // Delete all if no list provided\n    //     if (!aRoutes) aRoutes = this.config.routes\n    //     if (!Array.isArray(aRoutes)) aRoutes = [aRoutes]\n    //     console.log('to be deleted', this.config.routes.filter(r => aRoutes.includes(r.id)))\n    //     console.log('to be retained', this.config.routes.filter(r => !aRoutes.includes(r.id)))\n\n    //     // TODO actually remove the unwanted route templates\n    //     // TODO remove from the config: this.config.routes = this.config.routes.filter(r => !aRoutes.includes(r.id))\n\n    //     // ? Optional future upgrade - attempt to also remove any links to this route?\n    // }\n\n    // TODO\n    // reloadTemplates(templateIds) {\n    //     if (!Array.isArray(templateIds)) templateIds = [templateIds]\n    //     templateIds.forEach( templateid => {\n    //         // TODO reload\n    //     } )\n    // }\n} // ---- End of class ----\n\n// For use in ESM loads\nexport { UibRouter }\nexport default UibRouter\n\n// Auto-assign for when the library is loaded via a script tag\nif (!window['UibRouter']) {\n    window['UibRouter'] = UibRouter\n} else {\n    console.warn('`UibRouter` already assigned to window. Have you tried to load it more than once?')\n}\n"],
  "mappings": "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",
  "names": ["_instanceExists", "_startDone", "_UibRouter", "routerConfig", "__publicField", "__privateAdd", "__privateGet", "r", "results", "res", "reason", "__privateSet", "body", "routeContainerEl", "tempContainer", "loadedElements", "head", "errors", "element", "event", "routeDefinition", "id", "response", "e", "htmlText", "chkTemplate", "scr", "newScript", "str", "lang", "high", "plugin", "name", "routeDefns", "defn", "fmt", "newRouteId", "routeSource", "container", "currentHash", "oldRouteId", "newUrl", "routeShown", "oldContent", "content", "extOther", "f", "parent", "routeId", "routeParentEl", "rContent", "docFrag", "loadedEls", "routeConfig", "url", "returnHash", "routeDefn", "externalOnly", "templateIds", "item", "thisRoute", "mdText", "UibRouter", "uibrouter_default", "UibRouter"]
}
