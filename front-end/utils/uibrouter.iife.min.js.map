{
  "version": 3,
  "sources": ["src/front-end-module/uibrouter.js"],
  "sourcesContent": ["/* eslint-disable no-undef */\n// @ts-nocheck\n/** A simple, vanilla JavaScript front-end router class\n * Included in node-red-contrib-uibuilder but is not dependent on it.\n * May be used in other contexts as desired.\n * \n * Copyright (c) 2023-2024 Julian Knight (Totally Information)\n * https://it.knightnet.org.uk\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** Type definitions\n * routeDefinition\n * @typedef {object} routeDefinition Single route configuration\n * @property {string} id REQUIRED. Route ID\n * @property {string} src REQUIRED. CSS Selector for template tag routes, url for external routes\n * @property {\"url\"|undefined} [type] OPTIONAL. \"url\" for external routes\n * @property {string} [title] OPTIONAL. Text to use as a short title for the route\n * @property {string} [description] OPTIONAL. Text to use as a long description for the route\n * UibRouterConfig\n * @typedef {object} UibRouterConfig Configuration for the UiBRouter class instances\n * @property {routeDefinition[]} routes REQUIRED. Array of route definitions\n * @property {string} [defaultRoute] OPTIONAL. If set to a route id, that route will be automatically shown on load\n * @property {string} [routeContainer] OPTIONAL. CSS Selector for an HTML Element containing routes\n * @property {boolean} [hide] OPTIONAL. If TRUE, routes will be hidden/shown on change instead of removed/added\n * @property {boolean} [unload] OPTIONAL. If TRUE, route templates will be unloaded from DOM after access. Only useful with the `hide` option\n */\n\nclass UibRouter { // eslint-disable-line no-unused-vars\n    //#region --- Variables ---\n    /** Class version */\n    static version = '1.0.2'\n\n    /** Configuration settings @type {UibRouterConfig} */\n    config\n    /** Reference to the container DOM element - set in setup() @type {HTMLDivElement} */\n    routeContainerEl\n    /** The current route id after doRoute() has been called */\n    currentRouteId\n    /** The previous route id after doRoute() has been called */\n    previousRouteId\n    /** Array of route ID's (created in constructor) */\n    routeIds = []\n\n    /** Internal only. Set to true when the _start() method has been called */\n    #startDone = false\n    //#endregion --- ----- ---\n\n    //#region --- Internal Methods ---\n    /** Class constructor\n     * @param {UibRouterConfig} routerConfig Configuration object\n     */\n    constructor(routerConfig) {\n        // Fetch is on desktop browsers since 2017 at latest. Not so much on mobile (Android!)\n        // May need a polyfill on mobile or old browsers.\n        if (!fetch) throw new Error('[uibrouter:constructor] UibRouter requires `fetch`. Please use a current browser or load a fetch polyfill.')\n\n        if (!routerConfig) throw new Error('[uibrouter:constructor] No config provided')\n        if (!routerConfig.routes) throw new Error('[uibrouter:constructor] No routes provided in routerConfig')\n        // Add a default route container uf needed\n        if (!routerConfig.routeContainer)routerConfig.routeContainer = '#uibroutecontainer'\n\n        // Save the config\n        this.config = routerConfig\n        // If no default set in config, set to the first entry\n        if (!this.config.defaultRoute && this.config.routes[0] && this.config.routes[0].id) this.config.defaultRoute = this.config.routes[0].id\n        // Create/access the route container element, sets this.routeContainerEl\n        this._setRouteContainer()\n\n        this._updateRouteIds()\n\n        // Load all external route templates async in parallel - NB: Object.values works on both arrays and objects\n        // Note that final `then` is called even if no external routes are given\n        Promise.all(Object.values(routerConfig.routes).filter(r => r.type && r.type === 'url').map(this._loadExternal))\n            .then(this._appendExternalTemplates)\n            .then( () => {\n                // Everything is loaded so we can start\n                this._start()\n                return true\n            } )\n            .catch( reason => {\n                console.error(reason)\n            })\n    }\n\n    /** Save a reference to, and create if necessary, the HTML element to hold routes */\n    _setRouteContainer() {\n        const body = document.getElementsByTagName('body')[0]\n        // Get reference to route container or create it\n        let routeContainerEl = this.routeContainerEl = document.querySelector(this.config.routeContainer)\n        if (!routeContainerEl) {\n            // throw new Error(`Route container element with CSS selector '${routerConfig.routeContainer}' not found in HTML`)\n            const tempContainer = document.createElement('div')\n            tempContainer.setAttribute('id', this.config.routeContainer.replace('#', ''))\n            body.append(tempContainer)\n            routeContainerEl = this.routeContainerEl = document.querySelector(this.config.routeContainer)\n        }\n    }\n\n    /** Load fetched external elements to templates tags under the head tag\n     * @param {HTMLElement[]} loadedElements Array of loaded external elements to add as templates to the head tag\n     */\n    _appendExternalTemplates(loadedElements) {\n        const head = document.getElementsByTagName('head')[0]\n        // Append the loaded content to the main container\n        loadedElements.forEach(element => {\n            if (Array.isArray(element)) {\n                console.error(...element)\n            } else {\n                head.append(element)\n            }\n        })\n    }\n\n    /** Called once all external templates have been loaded */\n    _start() {\n        if (this.#startDone === true) return // Don't run this again\n\n        // Go to default route if no route in url and if a default is defined or ensure current route is shown\n        this.doRoute(this.keepHashFromUrl(window.location.hash))\n\n        // After initial route set, listen for url hash changes and process route change\n        window.addEventListener('hashchange', (event) => this._hashChange(event) )\n\n        // Events on fully loaded ...\n        document.dispatchEvent(new CustomEvent('uibrouter:loaded'))\n        if (uibuilder) uibuilder.set('uibrouter', 'loaded') // eslint-disable-line no-undef\n\n        this.#startDone = true // Don't run this again\n    }\n\n    /** Called when the URL Hash changes\n     * @param {HashChangeEvent} event URL Hash change event object\n     */\n    _hashChange(event) {\n        // console.log(`[uibrouter] hashchange: ${this.keepHashFromUrl(event.oldURL)} => ${this.keepHashFromUrl(event.newURL)}` )\n        this.doRoute(event)\n    }\n\n    /** Create DOM route content from a route template (internal or external)\n     * Route templates have to be a `<template>` tag with an ID that matches the route id.\n     * @param {string} routeId ID of the route definition to use to create the content\n     * @returns {boolean} True if the route content was created successfully, false otherwise\n     */\n    _createRouteContent(routeId) {\n        const rContent = document.querySelector(`#${routeId}`)\n        if (!rContent) {\n            console.error(`[uibrouter:createRouteContent] No route template found for route selector '#${routeId}'. Does the link url match a defined route id?`)\n            return false\n        }\n        const docFrag = rContent.content.cloneNode(true)\n        // Have to re-apply the scripts to make them run - only for external templates\n        if (this.isRouteExternal(routeId)) this._applyScripts(docFrag)\n        // Create the route wrapper div with data-route attrib\n        const tempContainer = document.createElement('div')\n        tempContainer.dataset.route = routeId\n        tempContainer.append(docFrag)\n        // And finally try to append to the container\n        try {\n            this.routeContainerEl.append(tempContainer)\n        } catch (e) {\n            console.error(`[uibrouter:createRouteContent] Failed to apply route id '${routeId}'. \\n ${e.message}`)\n            return false\n        }\n        return true\n    }\n\n    /** Loads an external HTML file into a `<template>` tag, adding the router id as the template id.\n     *  or returns an error array\n     * @param {routeDefinition} routeDefinition Configuration for a single route\n     * @returns {Promise<HTMLTemplateElement[]|[string,string,number,string]>} A promise that fulfills to an HTMLTemplateElement or an array containing error information\n     */\n    _loadExternal(routeDefinition) {\n        // const id = singleConfig.src.split('/').pop().replace('.html','')\n        const id = routeDefinition.id\n        // @ts-ignore\n        return fetch(routeDefinition.src)\n            .then(response => {\n                // Fetch failed?\n                if (response.ok === false) return [routeDefinition.id, routeDefinition.src, response.status, response.statusText]\n                return response.text()\n            })\n            .then((/** @type {string} */ htmlText) => {\n                if (Array.isArray(htmlText)) return htmlText // if the fetch failed\n\n                // Check to see if template already exists, if so, remove it\n                try {\n                    const chkTemplate = document.querySelector(`#${id}`)\n                    if (chkTemplate) chkTemplate.remove()\n                } catch (e) {}\n\n                const tempContainer = document.createElement('template')\n                tempContainer.innerHTML = htmlText\n                tempContainer.setAttribute('id', id)\n                return tempContainer\n            })\n            .catch(error => {\n                console.error(`[uibrouter:loadHTML] Error loading route template HTML from ${routeDefinition.src}:`, error)\n            })\n    }\n\n    /** Remove/re-apply scripts in a container Element so that they are executed.\n     * @param {HTMLElement} tempContainer HTML Element of container to process\n     */\n    _applyScripts(tempContainer) {\n        const scripts = tempContainer.querySelectorAll('script')\n        scripts.forEach( scr => {\n            const newScript = document.createElement('script')\n            newScript.textContent = scr.innerText\n            tempContainer.append(newScript)\n            scr.remove() // remove the origin\n        })\n    }\n\n    /** Update this.routeIds array from this.config (on start and after add/remove routes) */\n    _updateRouteIds() {\n        this.routeIds = new Set(Object.values(routerConfig.routes).map( r => r.id ))\n    }\n    //#endregion --- ----- --\n\n    /** Process a routing request\n     * @param {PointerEvent|MouseEvent|HashChangeEvent|TouchEvent|string} routeSource Either string containing route id or DOM Event object either click/touch on element containing `href=\"#routeid\"` or Hash URL change event\n     */\n    doRoute(routeSource) {\n        if (!routeSource) routeSource = this.config.defaultRoute\n\n        const container = this.routeContainerEl\n        if (!container) throw new Error('[uibrouter:doRoute] Cannot route, has router.setup() been called yet?')\n\n        // Remove all the url and query param text and any leading # - returns '' if no current hash\n        const currentHash = this.keepHashFromUrl(window.location.hash)\n\n        // If no route source provided, take the current hash (which might be '' and that will trigger the default route if defined)\n        if (!routeSource) routeSource = currentHash\n\n        let newRouteId, oldRouteId\n\n        // Define new and old routes depending on different call types\n        if (typeof routeSource === 'string') { // Manually provided route id\n            // console.log(`[uibrouter:doRoute] manual: ${currentHash} => ${this.keepHashFromUrl(routeSource)}. Current: ${currentHash}` )\n            newRouteId = this.keepHashFromUrl(routeSource)\n            oldRouteId = currentHash\n            // If no hash & config has default, set the default as new\n            if (newRouteId === '' && this.config.defaultRoute) newRouteId = this.config.defaultRoute\n            // If the new route id not the same as the current one in the url hash, just change the current hash & exit\n            if (newRouteId !== currentHash ) {\n                window.location.hash = `#${newRouteId}`\n                return\n            }\n        } else if (routeSource.type === 'hashchange') { // A URL Hash change event\n            // console.log(`[uibrouter:doRoute] hashchange: ${this.keepHashFromUrl(routeSource.oldURL)} => ${this.keepHashFromUrl(routeSource.newURL)}. Current: ${currentHash}` )\n            const newUrl = routeSource.newURL\n            // Check if URL actually contains a #\n            if (newUrl.includes('#')) {\n                oldRouteId = this.keepHashFromUrl(routeSource.oldURL)\n                newRouteId = this.keepHashFromUrl(newUrl) // Only keep anything after the # & ignoring query params\n            } else return\n        } else { // A mouse click/touch event on a dom element with an href attribute\n            oldRouteId = currentHash\n            // Try to get the route name from the URL hash\n            try {\n                newRouteId = this.keepHashFromUrl(routeSource.target.attributes.href.value) // Only keep anything after the # & ignoring query params\n            } catch (e) {\n                throw new Error('[uibrouter:doRoute] No valid route found. Event.target does not have an href attribute')\n            }\n        }\n\n        let routeShown = false\n\n        // If no defined valid route, undo and report error\n        if (!newRouteId || !this.routeIds.has(newRouteId)) {\n            // Events on route change fail ...\n            document.dispatchEvent(new CustomEvent('uibrouter:route-change-failed', { detail: { newRouteId, oldRouteId } }))\n            if (uibuilder) uibuilder.set('uibrouter', 'route change failed') // eslint-disable-line no-undef\n\n            // If the same, this happened on load and would keep failing so revert to default\n            if (newRouteId === oldRouteId) oldRouteId = ''\n            // Revert route\n            this.doRoute(oldRouteId || '')\n\n            // Don't throw an error here, it stops the menu highlighting from working\n            console.error(`[uibrouter:doRoute] No valid route found. Either pass a valid route name or an event from an element having an href of '#${newRouteId}'. Route id requested: '${newRouteId}'`)\n            return\n        }\n\n        // Show the new container (replace or show)\n        if (this.config.hide) {\n            // config.hide = true so hide previous contents\n            if (oldRouteId) {\n                /** @type {HTMLElement|null} */\n                const oldContent = document.querySelector(`div[data-route=\"${oldRouteId}\"]`)\n                if (oldContent) oldContent.style.display = 'none'\n            }\n            /** and unhide new route if possible @type {HTMLElement|null} */\n            const content = document.querySelector(`div[data-route=\"${newRouteId}\"]`)\n            if (content) {\n                content.style.removeProperty('display')\n                routeShown = true\n            } else {\n                // else create new content from template\n                routeShown = this._createRouteContent(newRouteId)\n            }\n        } else {\n            // config.hide != true so remove previous contents\n            container.replaceChildren()\n            // Create new content from template\n            routeShown = this._createRouteContent(newRouteId)\n        }\n\n        // console.log({ newRouteId, oldRouteId, currentHash, routeShown })\n\n        // Roll back the route change if the new route cannot be shown\n        if (routeShown === false) {\n            // Events on route change fail ...\n            document.dispatchEvent(new CustomEvent('uibrouter:route-change-failed', { detail: { newRouteId, oldRouteId } }))\n            if (uibuilder) uibuilder.set('uibrouter', 'route change failed') // eslint-disable-line no-undef\n\n            window.location.hash = oldRouteId ? `#${oldRouteId}` : ''\n            return\n        }\n\n        // Retain current and previous route id's\n        this.currentRouteId = newRouteId\n        this.previousRouteId = oldRouteId\n\n        // Record the current route on the route container\n        container.dataset.currentRoute = newRouteId\n\n        // Update any existing HTML menu items\n        this.setCurrentMenuItems()\n\n        // Events on route changed ...\n        document.dispatchEvent(new CustomEvent('uibrouter:route-changed', { detail: { newRouteId, oldRouteId } }))\n        if (uibuilder) {\n            uibuilder.set('uibrouter', 'route changed')\n            uibuilder.set('uibrouter_CurrentRoute', newRouteId)\n            uibuilder.set('uibrouter_CurrentTitle', this.routeTitle())\n            uibuilder.set('uibrouter_CurrentDescription', this.routeDescription())\n            uibuilder.set('uibrouter_CurrentDetails', this.getRouteConfigById(newRouteId))\n        }\n    }\n\n    /** Return a route config given a route id (returns undefined if route not found)\n     * @param {string} routeId Route ID to search for\n     * @returns {routeDefinition|undefined} Route config for found id else undefined\n     */\n    getRouteConfigById(routeId) {\n        return Object.values(this.config.routes).filter(r => r.id === routeId)[0]\n    }\n\n    /** Return true if the given route is external, false otherwise\n     * Used to correctly (re)apply script tags when cloning the template to the DOM (createRouteContent)\n     * @param {string} routeId Route ID to check\n     * @returns {boolean} True if the given route is external, false otherwise\n     */\n    isRouteExternal(routeId) {\n        const routeConfig = this.getRouteConfigById(routeId)\n        return !!(routeConfig && routeConfig.type === 'url')\n    }\n\n    /** Go to the default route if it has been specified */\n    defaultRoute() {\n        if (this.config.defaultRoute) this.doRoute(this.config.defaultRoute)\n    }\n\n    /** Remove the hash from the browser URL */\n    removeHash() {\n        history.pushState('', document.title, window.location.pathname + window.location.search)\n    }\n\n    /** Empty the current container and remove url hash - does not trigger a route change */\n    noRoute() {\n        this.removeHash()\n        this.routeContainerEl.replaceChildren()\n    }\n\n    /** Only keep anything after the # & ignoring query params\n     * @param {string} url URL to extract the hash from\n     * @returns {string} Just the route id\n     */\n    keepHashFromUrl(url) {\n        if (!url) return ''\n        return url.replace(/^.*#(.*)/, '$1').replace(/\\?.*$/, '')\n    }\n\n    /** Return an array of route ids (to facilitate creation of menus)\n     * @param {boolean} returnHash If true, returns id's with leading `#` to apply to href attributes else returns the id\n     * @returns {string[]} Array of route id's or route url hashes\n     */\n    routeList(returnHash) {\n        if (returnHash === true) return this.routeIds.map((r) => returnHash === true ? `#${r.id}` : r.id)\n        return this.routeIds\n    }\n\n    /** Add new route definitions to the existing ones\n     * @param {routeDefinition|routeDefinition[]} routeDefn Single or array of route definitions to add\n     */\n    addRoutes(routeDefn) {\n        if (!Array.isArray(routeDefn)) routeDefn = [routeDefn]\n        // Load all external route templates async in parallel - NB: Object.values works on both arrays and objects\n        // Note that final `then` is called even if no external routes are given\n        Promise.all(Object.values(routeDefn).filter(r => r.type && r.type === 'url').map(this._loadExternal)) // eslint-disable-line promise/catch-or-return\n            .then(this._appendExternalTemplates)\n            .then( () => { // eslint-disable-line promise/always-return\n                // Everything is loaded - Add new routes to config\n                this.config.routes.push(...routeDefn)\n                // and update the routeIds list\n                this._updateRouteIds()\n                // Let everyone know it all finished\n                document.dispatchEvent(new CustomEvent('uibrouter:routes-added', { detail: routeDefn }))\n                if (uibuilder) uibuilder.set('uibrouter', 'routes added') // eslint-disable-line no-undef, promise/always-return\n            } )\n    }\n\n    //#region --- utils for page display & processing ---\n    setCurrentMenuItems() {\n        // const items = document.querySelectorAll(`li[data-route=\"${this.currentRouteId}\"]`)\n        const items = document.querySelectorAll('li[data-route]')\n        items.forEach( item => {\n            if (item.dataset.route === this.currentRouteId) {\n                item.classList.add('currentRoute')\n                item.setAttribute('aria-current', 'page')\n            } else {\n                item.classList.remove('currentRoute')\n                item.removeAttribute('aria-current')\n            }\n        })\n    }\n\n    routeTitle() {\n        const thisRoute = this.currentRoute() || {}\n        return thisRoute.title || thisRoute.id || '[ROUTE NOT FOUND]'\n    }\n\n    routeDescription() {\n        const thisRoute = this.currentRoute() || {}\n        return thisRoute.description || thisRoute.id || '[ROUTE NOT FOUND]'\n    }\n\n    currentRoute() {\n        return this.getRouteConfigById(this.currentRouteId)\n    }\n    //#endregion ---- ----- ----\n\n    // TODO\n    // deleteRoutes(aRoutes) {\n    //     // Delete all if no list provided\n    //     if (!aRoutes) aRoutes = this.config.routes\n    //     if (!Array.isArray(aRoutes)) aRoutes = [aRoutes]\n    //     console.log('to be deleted', this.config.routes.filter(r => aRoutes.includes(r.id)))\n    //     console.log('to be retained', this.config.routes.filter(r => !aRoutes.includes(r.id)))\n\n    //     // TODO actually remove the unwanted route templates\n    //     // TODO remove from the config: this.config.routes = this.config.routes.filter(r => !aRoutes.includes(r.id))\n\n    //     // ? Optional future upgrade - attempt to also remove any links to this route?\n    // }\n\n    // TODO\n    // deleteTemplates(templateIds) {\n    //     if (!Array.isArray(templateIds)) templateIds = [templateIds]\n    //     templateIds.forEach( templateid => {\n    //         // TODO delete\n    //     } )\n    // }\n\n    // TODO\n    // reloadTemplates(templateIds) {\n    //     if (!Array.isArray(templateIds)) templateIds = [templateIds]\n    //     templateIds.forEach( templateid => {\n    //         // TODO reload\n    //     } )\n    // }\n} // ---- End of class ----\n\n// For use in ESM loads\nexport { UibRouter }\nexport default UibRouter\n\n// Auto-assign for when the library is loaded via a script tag\nif (!window['UibRouter']) {\n    window['UibRouter'] = UibRouter\n} else {\n    console.warn('`UibRouter` already assigned to window. Have you tried to load it more than once?')\n}\n"],
  "mappings": "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",
  "names": ["_startDone", "UibRouter", "routerConfig", "__publicField", "__privateAdd", "r", "reason", "body", "routeContainerEl", "tempContainer", "loadedElements", "head", "element", "__privateGet", "event", "__privateSet", "routeId", "rContent", "docFrag", "e", "routeDefinition", "id", "response", "htmlText", "chkTemplate", "error", "scr", "newScript", "routeSource", "container", "currentHash", "newRouteId", "oldRouteId", "newUrl", "routeShown", "oldContent", "content", "routeConfig", "url", "returnHash", "routeDefn", "item", "thisRoute", "uibrouter_default", "UibRouter"]
}
